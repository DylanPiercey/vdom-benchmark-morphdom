{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/set-dom/src/index.js","node_modules/set-dom/src/parse-html.js","node_modules/vdom-benchmark-base/lib/benchmark.js","node_modules/vdom-benchmark-base/lib/executor.js","node_modules/vdom-benchmark-base/lib/index.js","package.json","web/js/main.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict'\n\nsetDOM.KEY = 'data-key'\nsetDOM.IGNORE = 'data-ignore'\nsetDOM.CHECKSUM = 'data-checksum'\nvar parseHTML = require('./parse-html')\nvar KEY_PREFIX = '_set-dom-'\nvar NODE_MOUNTED = KEY_PREFIX + 'mounted'\nvar MOUNT_EVENT = 'mount'\nvar DISMOUNT_EVENT = 'dismount'\nvar ELEMENT_TYPE = 1\nvar DOCUMENT_TYPE = 9\nvar DOCUMENT_FRAGMENT_TYPE = 11\n\n// Expose api.\nmodule.exports = setDOM\n\n/**\n * @description\n * Updates existing dom to match a new dom.\n *\n * @param {Node} oldNode - The html entity to update.\n * @param {String|Node} newNode - The updated html(entity).\n */\nfunction setDOM (oldNode, newNode) {\n  // Ensure a realish dom node is provided.\n  assert(oldNode && oldNode.nodeType, 'You must provide a valid node to update.')\n\n  // Alias document element with document.\n  if (oldNode.nodeType === DOCUMENT_TYPE) oldNode = oldNode.documentElement\n\n  // Document Fragments don't have attributes, so no need to look at checksums, ignored, attributes, or node replacement.\n  if (newNode.nodeType === DOCUMENT_FRAGMENT_TYPE) {\n    // Simply update all children (and subchildren).\n    setChildNodes(oldNode, newNode)\n  } else {\n    // Otherwise we diff the entire old node.\n    setNode(oldNode, typeof newNode === 'string'\n      // If a string was provided we will parse it as dom.\n      ? parseHTML(newNode, oldNode.nodeName)\n      : newNode\n    )\n  }\n\n  // Trigger mount events on initial set.\n  if (!oldNode[NODE_MOUNTED]) {\n    oldNode[NODE_MOUNTED] = true\n    dispatch(oldNode, MOUNT_EVENT)\n  }\n}\n\n/**\n * @private\n * @description\n * Updates a specific htmlNode and does whatever it takes to convert it to another one.\n *\n * @param {Node} oldNode - The previous HTMLNode.\n * @param {Node} newNode - The updated HTMLNode.\n */\nfunction setNode (oldNode, newNode) {\n  if (oldNode.nodeType === newNode.nodeType) {\n    // Handle regular element node updates.\n    if (oldNode.nodeType === ELEMENT_TYPE) {\n      // Ignore elements if their checksum matches.\n      if (getCheckSum(oldNode) === getCheckSum(newNode)) return\n      // Ignore elements that explicity choose not to be diffed.\n      if (isIgnored(oldNode) && isIgnored(newNode)) return\n\n      // Update all children (and subchildren).\n      setChildNodes(oldNode, newNode)\n\n      // Update the elements attributes / tagName.\n      if (oldNode.nodeName === newNode.nodeName) {\n        // If we have the same nodename then we can directly update the attributes.\n        setAttributes(oldNode.attributes, newNode.attributes)\n      } else {\n        // Otherwise clone the new node to use as the existing node.\n        var newPrev = newNode.cloneNode()\n        // Copy over all existing children from the original node.\n        while (oldNode.firstChild) newPrev.appendChild(oldNode.firstChild)\n        // Replace the original node with the new one with the right tag.\n        oldNode.parentNode.replaceChild(newPrev, oldNode)\n      }\n    } else {\n      // Handle other types of node updates (text/comments/etc).\n      // If both are the same type of node we can update directly.\n      if (oldNode.nodeValue !== newNode.nodeValue) {\n        oldNode.nodeValue = newNode.nodeValue\n      }\n    }\n  } else {\n    // we have to replace the node.\n    dispatch(oldNode, DISMOUNT_EVENT)\n    oldNode.parentNode.replaceChild(newNode, oldNode)\n    dispatch(newNode, MOUNT_EVENT)\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will update one list of attributes to match another.\n *\n * @param {NamedNodeMap} oldAttributes - The previous attributes.\n * @param {NamedNodeMap} newAttributes - The updated attributes.\n */\nfunction setAttributes (oldAttributes, newAttributes) {\n  var i, a, b, ns, name\n\n  // Remove old attributes.\n  for (i = oldAttributes.length; i--;) {\n    a = oldAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = newAttributes.getNamedItemNS(ns, name)\n    if (!b) oldAttributes.removeNamedItemNS(ns, name)\n  }\n\n  // Set new attributes.\n  for (i = newAttributes.length; i--;) {\n    a = newAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = oldAttributes.getNamedItemNS(ns, name)\n    if (!b) {\n      // Add a new attribute.\n      newAttributes.removeNamedItemNS(ns, name)\n      oldAttributes.setNamedItemNS(a)\n    } else if (b.value !== a.value) {\n      // Update existing attribute.\n      b.value = a.value\n    }\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will nodes childern to match another nodes children.\n *\n * @param {Node} oldParent - The existing parent node.\n * @param {Node} newParent - The new parent node.\n */\nfunction setChildNodes (oldParent, newParent) {\n  var checkOld, oldKey, checkNew, newKey, foundNode, keyedNodes\n  var oldNode = oldParent.firstChild\n  var newNode = newParent.firstChild\n  var extra = 0\n\n  // Extract keyed nodes from previous children and keep track of total count.\n  while (oldNode) {\n    extra++\n    checkOld = oldNode\n    oldKey = getKey(checkOld)\n    oldNode = oldNode.nextSibling\n\n    if (oldKey) {\n      if (!keyedNodes) keyedNodes = {}\n      keyedNodes[oldKey] = checkOld\n    }\n  }\n\n  // Loop over new nodes and perform updates.\n  oldNode = oldParent.firstChild\n  while (newNode) {\n    extra--\n    checkNew = newNode\n    newNode = newNode.nextSibling\n\n    if (keyedNodes && (newKey = getKey(checkNew)) && (foundNode = keyedNodes[newKey])) {\n      delete keyedNodes[newKey]\n      // If we have a key and it existed before we move the previous node to the new position if needed and diff it.\n      if (foundNode !== oldNode) {\n        oldParent.insertBefore(foundNode, oldNode)\n      } else {\n        oldNode = oldNode.nextSibling\n      }\n\n      setNode(foundNode, checkNew)\n    } else if (oldNode) {\n      checkOld = oldNode\n      oldNode = oldNode.nextSibling\n      if (getKey(checkOld)) {\n        // If the old child had a key we skip over it until the end.\n        oldParent.insertBefore(checkNew, checkOld)\n        dispatch(checkNew, MOUNT_EVENT)\n      } else {\n        // Otherwise we diff the two non-keyed nodes.\n        setNode(checkOld, checkNew)\n      }\n    } else {\n      // Finally if there was no old node we add the new node.\n      oldParent.appendChild(checkNew)\n      dispatch(checkNew, MOUNT_EVENT)\n    }\n  }\n\n  // Remove old keyed nodes.\n  for (oldKey in keyedNodes) {\n    extra--\n    oldParent.removeChild(keyedNodes[oldKey])\n  }\n\n  // If we have any remaining unkeyed nodes remove them from the end.\n  while (--extra >= 0) {\n    oldParent.removeChild(dispatch(oldParent.lastChild, DISMOUNT_EVENT))\n  }\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a key out of an element.\n * Uses 'data-key' if possible and falls back to 'id'.\n *\n * @param {Node} node - The node to get the key for.\n * @return {string|void}\n */\nfunction getKey (node) {\n  if (node.nodeType !== ELEMENT_TYPE) return\n  var key = node.getAttribute(setDOM.KEY) || node.id\n  if (key) return KEY_PREFIX + key\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a checksum attribute from an element.\n * Uses 'data-checksum' or user specified checksum property.\n *\n * @param {Node} node - The node to get the checksum for.\n * @return {string|NaN}\n */\nfunction getCheckSum (node) {\n  return node.getAttribute(setDOM.CHECKSUM) || NaN\n}\n\n/**\n * @private\n * @description\n * Utility to try to check if an element should be ignored by the algorithm.\n * Uses 'data-ignore' or user specified ignore property.\n *\n * @param {Node} node - The node to check if it should be ignored.\n * @return {boolean}\n */\nfunction isIgnored (node) {\n  return node.getAttribute(setDOM.IGNORE) != null\n}\n\n/**\n * Recursively trigger an event for a node and it's children.\n * Only emits events for keyed nodes.\n *\n * @param {Node} node - the initial node.\n * @return {Node}\n */\nfunction dispatch (node, type) {\n  // Trigger event for this element if it has a key.\n  if (getKey(node)) {\n    var ev = document.createEvent('Event')\n    var prop = { value: node }\n    ev.initEvent(type, false, false)\n    Object.defineProperty(ev, 'target', prop)\n    Object.defineProperty(ev, 'srcElement', prop)\n    node.dispatchEvent(ev)\n  }\n\n  // Dispatch to all children.\n  var child = node.firstChild\n  while (child) child = dispatch(child, type).nextSibling\n  return node\n}\n\n/**\n * @private\n * @description\n * Confirm that a value is truthy, throws an error message otherwise.\n *\n * @param {*} val - the val to test.\n * @param {string} msg - the error message on failure.\n * @throws {Error}\n */\nfunction assert (val, msg) {\n  if (!val) throw new Error('set-dom: ' + msg)\n}\n","'use strict'\n\nvar parser = window.DOMParser && new window.DOMParser()\nvar documentRootName = 'HTML'\nvar supportsHTMLType = false\nvar supportsInnerHTML = false\nvar htmlType = 'text/html'\nvar xhtmlType = 'application/xhtml+xml'\nvar testCode = '<br/>'\n\n/* istanbul ignore next: Fails in older browsers */\ntry {\n  // Check if browser supports text/html DOMParser\n  if (parser.parseFromString(testCode, htmlType)) supportsHTMLType = true\n} catch (e) {\n  var mockDoc = document.implementation.createHTMLDocument('')\n  var mockHTML = mockDoc.documentElement\n  var mockBody = mockDoc.body\n  try {\n    // Check if browser supports documentElement.innerHTML\n    mockHTML.innerHTML += ''\n    supportsInnerHTML = true\n  } catch (e) {\n    // Check if browser supports xhtml parsing.\n    parser.parseFromString(testCode, xhtmlType)\n    var bodyReg = /(<body[^>]*>)([\\s\\S]*)<\\/body>/\n  }\n}\n\n/**\n * Returns the results of a DOMParser as an HTMLElement.\n * (Shims for older browsers).\n */\nmodule.exports = supportsHTMLType\n  ? function parseHTML (markup, rootName) {\n    var doc = parser.parseFromString(markup, htmlType)\n    return rootName === documentRootName\n      ? doc.documentElement\n      : doc.body.firstChild\n  }\n  /* istanbul ignore next: Only used in older browsers */\n  : function parseHTML (markup, rootName) {\n    // Fallback to innerHTML for other older browsers.\n    if (rootName === documentRootName) {\n      if (supportsInnerHTML) {\n        mockHTML.innerHTML = markup\n        return mockHTML\n      } else {\n        // IE9 does not support innerhtml at root level.\n        // We get around this by parsing everything except the body as xhtml.\n        var bodyMatch = markup.match(bodyReg)\n        if (bodyMatch) {\n          var bodyContent = bodyMatch[2]\n          var startBody = bodyMatch.index + bodyMatch[1].length\n          var endBody = startBody + bodyContent.length\n          markup = markup.slice(0, startBody) + markup.slice(endBody)\n          mockBody.innerHTML = bodyContent\n        }\n\n        var doc = parser.parseFromString(markup, xhtmlType)\n        var body = doc.body\n        while (mockBody.firstChild) body.appendChild(mockBody.firstChild)\n        return doc.documentElement\n      }\n    } else {\n      mockBody.innerHTML = markup\n      return mockBody.firstChild\n    }\n  }\n","'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n  this.enableTests = false;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }, undefined, false).start();\n  }, undefined, this.enableTests).start();\n};\n\nmodule.exports = Benchmark;\n","'use strict';\n\nfunction render(nodes) {\n  var children = [];\n  var j;\n  var c;\n  var i;\n  var e;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      e = document.createElement('div');\n      c = render(n.children);\n      for (j = 0; j < c.length; j++) {\n        e.appendChild(c[j]);\n      }\n      children.push(e);\n    } else {\n      e = document.createElement('span');\n      e.textContent = n.key.toString();\n      children.push(e);\n    }\n  }\n\n  return children;\n}\n\nfunction testInnerHtml(testName, nodes, container) {\n  var c = document.createElement('div');\n  var e = document.createElement('div');\n  var children = render(nodes);\n  for (var i = 0; i < children.length; i++) {\n    e.appendChild(children[i]);\n  }\n  c.appendChild(e);\n  if (c.innerHTML !== container.innerHTML) {\n    console.log('error in test: ' + testName);\n    console.log('container.innerHTML:');\n    console.log(container.innerHTML);\n    console.log('should be:');\n    console.log(c.innerHTML);\n  }\n}\n\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb, enableTests) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n  this.enableTests = enableTests;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'render()', test.data.a, this.container);\n      }\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'update()', test.data.b, this.container);\n      }\n\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n","'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.generateBenchmarkData().units;\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n\n  if (qs['test'] !== void 0) {\n    benchmark.enableTests = true;\n    console.log('tests enabled');\n  }\n\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n","module.exports={\n  \"private\": true,\n  \"name\": \"vdom-benchmark-set-dom\",\n  \"version\": \"0.2.0\",\n  \"description\": \"Virtual DOM Benchmark: set-dom\",\n  \"license\": \"BSD\",\n  \"repository\": \"https://github.com/localvoid/vdom-benchmark-set-dom\",\n  \"author\": {\n    \"name\": \"Boris Kaul\",\n    \"email\": \"localvoid@gmail.com\",\n    \"url\": \"https://github.com/localvoid\"\n  },\n  \"keywords\": [\n    \"virtual\",\n    \"dom\",\n    \"virtualdom\",\n    \"vdom\",\n    \"diff\",\n    \"browser\",\n    \"benchmark\",\n    \"vdom-benchmark\"\n  ],\n  \"dependencies\": {\n    \"envify\": \"~4.0.0\",\n    \"set-dom\": \"^7.3.3\",\n    \"vdom-benchmark-base\": \"~0.2.4\"\n  },\n  \"devDependencies\": {\n    \"browser-sync\": \"^2.18.8\",\n    \"browserify\": \"^14.1.0\",\n    \"del\": \"^2.2.2\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-gh-pages\": \"~0.5.4\",\n    \"gulp-if\": \"^2.0.2\",\n    \"gulp-sourcemaps\": \"^2.4.1\",\n    \"gulp-uglify\": \"^2.1.2\",\n    \"vinyl-buffer\": \"^1.0.0\",\n    \"vinyl-source-stream\": \"^1.1.0\"\n  }\n}\n","'use strict'\n\nvar benchmark = require('vdom-benchmark-base')\nvar setDOM = require('set-dom')\n\nvar NAME = 'set-dom'\nvar VERSION = require('../../package.json').dependencies['set-dom']\n\nfunction renderTree (nodes, parent, depth) {\n  var e\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i]\n    if (n.children !== null) {\n      e = document.createElement('div')\n      e.id = '' + depth + '_' + n.key\n      parent.appendChild(e)\n      renderTree(n.children, e, depth + 1)\n    } else {\n      e = document.createElement('span')\n      e.id = '' + depth + '_' + n.key\n      e.textContent = n.key\n      parent.appendChild(e)\n    }\n  }\n}\n\nfunction BenchmarkImpl (container, a, b) {\n  this.container = container\n  this.a = a\n  this.b = b\n  this._root = null\n}\n\nBenchmarkImpl.prototype.setUp = function () {}\n\nBenchmarkImpl.prototype.tearDown = function () {\n  this.container.removeChild(this.container.firstChild)\n}\n\nBenchmarkImpl.prototype.render = function () {\n  this._root = document.createElement('div')\n  renderTree(this.a, this._root, 0)\n  this.container.appendChild(this._root)\n}\n\nBenchmarkImpl.prototype.update = function () {\n  var e = document.createElement('div')\n  renderTree(this.b, e, 0)\n  setDOM(this._root, e)\n}\n\ndocument.addEventListener('DOMContentLoaded', function (e) {\n  benchmark(NAME, VERSION, BenchmarkImpl)\n}, false)\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvc2V0LWRvbS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2V0LWRvbS9zcmMvcGFyc2UtaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy92ZG9tLWJlbmNobWFyay1iYXNlL2xpYi9iZW5jaG1hcmsuanMiLCJub2RlX21vZHVsZXMvdmRvbS1iZW5jaG1hcmstYmFzZS9saWIvZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvdmRvbS1iZW5jaG1hcmstYmFzZS9saWIvaW5kZXguanMiLCJwYWNrYWdlLmpzb24iLCJ3ZWIvanMvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnXG5cbnNldERPTS5LRVkgPSAnZGF0YS1rZXknXG5zZXRET00uSUdOT1JFID0gJ2RhdGEtaWdub3JlJ1xuc2V0RE9NLkNIRUNLU1VNID0gJ2RhdGEtY2hlY2tzdW0nXG52YXIgcGFyc2VIVE1MID0gcmVxdWlyZSgnLi9wYXJzZS1odG1sJylcbnZhciBLRVlfUFJFRklYID0gJ19zZXQtZG9tLSdcbnZhciBOT0RFX01PVU5URUQgPSBLRVlfUFJFRklYICsgJ21vdW50ZWQnXG52YXIgTU9VTlRfRVZFTlQgPSAnbW91bnQnXG52YXIgRElTTU9VTlRfRVZFTlQgPSAnZGlzbW91bnQnXG52YXIgRUxFTUVOVF9UWVBFID0gMVxudmFyIERPQ1VNRU5UX1RZUEUgPSA5XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfVFlQRSA9IDExXG5cbi8vIEV4cG9zZSBhcGkuXG5tb2R1bGUuZXhwb3J0cyA9IHNldERPTVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVXBkYXRlcyBleGlzdGluZyBkb20gdG8gbWF0Y2ggYSBuZXcgZG9tLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gb2xkTm9kZSAtIFRoZSBodG1sIGVudGl0eSB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBuZXdOb2RlIC0gVGhlIHVwZGF0ZWQgaHRtbChlbnRpdHkpLlxuICovXG5mdW5jdGlvbiBzZXRET00gKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgLy8gRW5zdXJlIGEgcmVhbGlzaCBkb20gbm9kZSBpcyBwcm92aWRlZC5cbiAgYXNzZXJ0KG9sZE5vZGUgJiYgb2xkTm9kZS5ub2RlVHlwZSwgJ1lvdSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBub2RlIHRvIHVwZGF0ZS4nKVxuXG4gIC8vIEFsaWFzIGRvY3VtZW50IGVsZW1lbnQgd2l0aCBkb2N1bWVudC5cbiAgaWYgKG9sZE5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX1RZUEUpIG9sZE5vZGUgPSBvbGROb2RlLmRvY3VtZW50RWxlbWVudFxuXG4gIC8vIERvY3VtZW50IEZyYWdtZW50cyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMsIHNvIG5vIG5lZWQgdG8gbG9vayBhdCBjaGVja3N1bXMsIGlnbm9yZWQsIGF0dHJpYnV0ZXMsIG9yIG5vZGUgcmVwbGFjZW1lbnQuXG4gIGlmIChuZXdOb2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgLy8gU2ltcGx5IHVwZGF0ZSBhbGwgY2hpbGRyZW4gKGFuZCBzdWJjaGlsZHJlbikuXG4gICAgc2V0Q2hpbGROb2RlcyhvbGROb2RlLCBuZXdOb2RlKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSB3ZSBkaWZmIHRoZSBlbnRpcmUgb2xkIG5vZGUuXG4gICAgc2V0Tm9kZShvbGROb2RlLCB0eXBlb2YgbmV3Tm9kZSA9PT0gJ3N0cmluZydcbiAgICAgIC8vIElmIGEgc3RyaW5nIHdhcyBwcm92aWRlZCB3ZSB3aWxsIHBhcnNlIGl0IGFzIGRvbS5cbiAgICAgID8gcGFyc2VIVE1MKG5ld05vZGUsIG9sZE5vZGUubm9kZU5hbWUpXG4gICAgICA6IG5ld05vZGVcbiAgICApXG4gIH1cblxuICAvLyBUcmlnZ2VyIG1vdW50IGV2ZW50cyBvbiBpbml0aWFsIHNldC5cbiAgaWYgKCFvbGROb2RlW05PREVfTU9VTlRFRF0pIHtcbiAgICBvbGROb2RlW05PREVfTU9VTlRFRF0gPSB0cnVlXG4gICAgZGlzcGF0Y2gob2xkTm9kZSwgTU9VTlRfRVZFTlQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBVcGRhdGVzIGEgc3BlY2lmaWMgaHRtbE5vZGUgYW5kIGRvZXMgd2hhdGV2ZXIgaXQgdGFrZXMgdG8gY29udmVydCBpdCB0byBhbm90aGVyIG9uZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9sZE5vZGUgLSBUaGUgcHJldmlvdXMgSFRNTE5vZGUuXG4gKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgLSBUaGUgdXBkYXRlZCBIVE1MTm9kZS5cbiAqL1xuZnVuY3Rpb24gc2V0Tm9kZSAob2xkTm9kZSwgbmV3Tm9kZSkge1xuICBpZiAob2xkTm9kZS5ub2RlVHlwZSA9PT0gbmV3Tm9kZS5ub2RlVHlwZSkge1xuICAgIC8vIEhhbmRsZSByZWd1bGFyIGVsZW1lbnQgbm9kZSB1cGRhdGVzLlxuICAgIGlmIChvbGROb2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX1RZUEUpIHtcbiAgICAgIC8vIElnbm9yZSBlbGVtZW50cyBpZiB0aGVpciBjaGVja3N1bSBtYXRjaGVzLlxuICAgICAgaWYgKGdldENoZWNrU3VtKG9sZE5vZGUpID09PSBnZXRDaGVja1N1bShuZXdOb2RlKSkgcmV0dXJuXG4gICAgICAvLyBJZ25vcmUgZWxlbWVudHMgdGhhdCBleHBsaWNpdHkgY2hvb3NlIG5vdCB0byBiZSBkaWZmZWQuXG4gICAgICBpZiAoaXNJZ25vcmVkKG9sZE5vZGUpICYmIGlzSWdub3JlZChuZXdOb2RlKSkgcmV0dXJuXG5cbiAgICAgIC8vIFVwZGF0ZSBhbGwgY2hpbGRyZW4gKGFuZCBzdWJjaGlsZHJlbikuXG4gICAgICBzZXRDaGlsZE5vZGVzKG9sZE5vZGUsIG5ld05vZGUpXG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZWxlbWVudHMgYXR0cmlidXRlcyAvIHRhZ05hbWUuXG4gICAgICBpZiAob2xkTm9kZS5ub2RlTmFtZSA9PT0gbmV3Tm9kZS5ub2RlTmFtZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHRoZSBzYW1lIG5vZGVuYW1lIHRoZW4gd2UgY2FuIGRpcmVjdGx5IHVwZGF0ZSB0aGUgYXR0cmlidXRlcy5cbiAgICAgICAgc2V0QXR0cmlidXRlcyhvbGROb2RlLmF0dHJpYnV0ZXMsIG5ld05vZGUuYXR0cmlidXRlcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjbG9uZSB0aGUgbmV3IG5vZGUgdG8gdXNlIGFzIHRoZSBleGlzdGluZyBub2RlLlxuICAgICAgICB2YXIgbmV3UHJldiA9IG5ld05vZGUuY2xvbmVOb2RlKClcbiAgICAgICAgLy8gQ29weSBvdmVyIGFsbCBleGlzdGluZyBjaGlsZHJlbiBmcm9tIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgICAgICB3aGlsZSAob2xkTm9kZS5maXJzdENoaWxkKSBuZXdQcmV2LmFwcGVuZENoaWxkKG9sZE5vZGUuZmlyc3RDaGlsZClcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgb3JpZ2luYWwgbm9kZSB3aXRoIHRoZSBuZXcgb25lIHdpdGggdGhlIHJpZ2h0IHRhZy5cbiAgICAgICAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdQcmV2LCBvbGROb2RlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgb3RoZXIgdHlwZXMgb2Ygbm9kZSB1cGRhdGVzICh0ZXh0L2NvbW1lbnRzL2V0YykuXG4gICAgICAvLyBJZiBib3RoIGFyZSB0aGUgc2FtZSB0eXBlIG9mIG5vZGUgd2UgY2FuIHVwZGF0ZSBkaXJlY3RseS5cbiAgICAgIGlmIChvbGROb2RlLm5vZGVWYWx1ZSAhPT0gbmV3Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgb2xkTm9kZS5ub2RlVmFsdWUgPSBuZXdOb2RlLm5vZGVWYWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBoYXZlIHRvIHJlcGxhY2UgdGhlIG5vZGUuXG4gICAgZGlzcGF0Y2gob2xkTm9kZSwgRElTTU9VTlRfRVZFTlQpXG4gICAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKVxuICAgIGRpc3BhdGNoKG5ld05vZGUsIE1PVU5UX0VWRU5UKVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVXRpbGl0eSB0aGF0IHdpbGwgdXBkYXRlIG9uZSBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0ge05hbWVkTm9kZU1hcH0gb2xkQXR0cmlidXRlcyAtIFRoZSBwcmV2aW91cyBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtOYW1lZE5vZGVNYXB9IG5ld0F0dHJpYnV0ZXMgLSBUaGUgdXBkYXRlZCBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzIChvbGRBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKSB7XG4gIHZhciBpLCBhLCBiLCBucywgbmFtZVxuXG4gIC8vIFJlbW92ZSBvbGQgYXR0cmlidXRlcy5cbiAgZm9yIChpID0gb2xkQXR0cmlidXRlcy5sZW5ndGg7IGktLTspIHtcbiAgICBhID0gb2xkQXR0cmlidXRlc1tpXVxuICAgIG5zID0gYS5uYW1lc3BhY2VVUklcbiAgICBuYW1lID0gYS5sb2NhbE5hbWVcbiAgICBiID0gbmV3QXR0cmlidXRlcy5nZXROYW1lZEl0ZW1OUyhucywgbmFtZSlcbiAgICBpZiAoIWIpIG9sZEF0dHJpYnV0ZXMucmVtb3ZlTmFtZWRJdGVtTlMobnMsIG5hbWUpXG4gIH1cblxuICAvLyBTZXQgbmV3IGF0dHJpYnV0ZXMuXG4gIGZvciAoaSA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgYSA9IG5ld0F0dHJpYnV0ZXNbaV1cbiAgICBucyA9IGEubmFtZXNwYWNlVVJJXG4gICAgbmFtZSA9IGEubG9jYWxOYW1lXG4gICAgYiA9IG9sZEF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtTlMobnMsIG5hbWUpXG4gICAgaWYgKCFiKSB7XG4gICAgICAvLyBBZGQgYSBuZXcgYXR0cmlidXRlLlxuICAgICAgbmV3QXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW1OUyhucywgbmFtZSlcbiAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtTlMoYSlcbiAgICB9IGVsc2UgaWYgKGIudmFsdWUgIT09IGEudmFsdWUpIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBhdHRyaWJ1dGUuXG4gICAgICBiLnZhbHVlID0gYS52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFV0aWxpdHkgdGhhdCB3aWxsIG5vZGVzIGNoaWxkZXJuIHRvIG1hdGNoIGFub3RoZXIgbm9kZXMgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtOb2RlfSBvbGRQYXJlbnQgLSBUaGUgZXhpc3RpbmcgcGFyZW50IG5vZGUuXG4gKiBAcGFyYW0ge05vZGV9IG5ld1BhcmVudCAtIFRoZSBuZXcgcGFyZW50IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHNldENoaWxkTm9kZXMgKG9sZFBhcmVudCwgbmV3UGFyZW50KSB7XG4gIHZhciBjaGVja09sZCwgb2xkS2V5LCBjaGVja05ldywgbmV3S2V5LCBmb3VuZE5vZGUsIGtleWVkTm9kZXNcbiAgdmFyIG9sZE5vZGUgPSBvbGRQYXJlbnQuZmlyc3RDaGlsZFxuICB2YXIgbmV3Tm9kZSA9IG5ld1BhcmVudC5maXJzdENoaWxkXG4gIHZhciBleHRyYSA9IDBcblxuICAvLyBFeHRyYWN0IGtleWVkIG5vZGVzIGZyb20gcHJldmlvdXMgY2hpbGRyZW4gYW5kIGtlZXAgdHJhY2sgb2YgdG90YWwgY291bnQuXG4gIHdoaWxlIChvbGROb2RlKSB7XG4gICAgZXh0cmErK1xuICAgIGNoZWNrT2xkID0gb2xkTm9kZVxuICAgIG9sZEtleSA9IGdldEtleShjaGVja09sZClcbiAgICBvbGROb2RlID0gb2xkTm9kZS5uZXh0U2libGluZ1xuXG4gICAgaWYgKG9sZEtleSkge1xuICAgICAgaWYgKCFrZXllZE5vZGVzKSBrZXllZE5vZGVzID0ge31cbiAgICAgIGtleWVkTm9kZXNbb2xkS2V5XSA9IGNoZWNrT2xkXG4gICAgfVxuICB9XG5cbiAgLy8gTG9vcCBvdmVyIG5ldyBub2RlcyBhbmQgcGVyZm9ybSB1cGRhdGVzLlxuICBvbGROb2RlID0gb2xkUGFyZW50LmZpcnN0Q2hpbGRcbiAgd2hpbGUgKG5ld05vZGUpIHtcbiAgICBleHRyYS0tXG4gICAgY2hlY2tOZXcgPSBuZXdOb2RlXG4gICAgbmV3Tm9kZSA9IG5ld05vZGUubmV4dFNpYmxpbmdcblxuICAgIGlmIChrZXllZE5vZGVzICYmIChuZXdLZXkgPSBnZXRLZXkoY2hlY2tOZXcpKSAmJiAoZm91bmROb2RlID0ga2V5ZWROb2Rlc1tuZXdLZXldKSkge1xuICAgICAgZGVsZXRlIGtleWVkTm9kZXNbbmV3S2V5XVxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGtleSBhbmQgaXQgZXhpc3RlZCBiZWZvcmUgd2UgbW92ZSB0aGUgcHJldmlvdXMgbm9kZSB0byB0aGUgbmV3IHBvc2l0aW9uIGlmIG5lZWRlZCBhbmQgZGlmZiBpdC5cbiAgICAgIGlmIChmb3VuZE5vZGUgIT09IG9sZE5vZGUpIHtcbiAgICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZShmb3VuZE5vZGUsIG9sZE5vZGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGROb2RlID0gb2xkTm9kZS5uZXh0U2libGluZ1xuICAgICAgfVxuXG4gICAgICBzZXROb2RlKGZvdW5kTm9kZSwgY2hlY2tOZXcpXG4gICAgfSBlbHNlIGlmIChvbGROb2RlKSB7XG4gICAgICBjaGVja09sZCA9IG9sZE5vZGVcbiAgICAgIG9sZE5vZGUgPSBvbGROb2RlLm5leHRTaWJsaW5nXG4gICAgICBpZiAoZ2V0S2V5KGNoZWNrT2xkKSkge1xuICAgICAgICAvLyBJZiB0aGUgb2xkIGNoaWxkIGhhZCBhIGtleSB3ZSBza2lwIG92ZXIgaXQgdW50aWwgdGhlIGVuZC5cbiAgICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZShjaGVja05ldywgY2hlY2tPbGQpXG4gICAgICAgIGRpc3BhdGNoKGNoZWNrTmV3LCBNT1VOVF9FVkVOVClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBkaWZmIHRoZSB0d28gbm9uLWtleWVkIG5vZGVzLlxuICAgICAgICBzZXROb2RlKGNoZWNrT2xkLCBjaGVja05ldylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluYWxseSBpZiB0aGVyZSB3YXMgbm8gb2xkIG5vZGUgd2UgYWRkIHRoZSBuZXcgbm9kZS5cbiAgICAgIG9sZFBhcmVudC5hcHBlbmRDaGlsZChjaGVja05ldylcbiAgICAgIGRpc3BhdGNoKGNoZWNrTmV3LCBNT1VOVF9FVkVOVClcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgb2xkIGtleWVkIG5vZGVzLlxuICBmb3IgKG9sZEtleSBpbiBrZXllZE5vZGVzKSB7XG4gICAgZXh0cmEtLVxuICAgIG9sZFBhcmVudC5yZW1vdmVDaGlsZChrZXllZE5vZGVzW29sZEtleV0pXG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgdW5rZXllZCBub2RlcyByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbmQuXG4gIHdoaWxlICgtLWV4dHJhID49IDApIHtcbiAgICBvbGRQYXJlbnQucmVtb3ZlQ2hpbGQoZGlzcGF0Y2gob2xkUGFyZW50Lmxhc3RDaGlsZCwgRElTTU9VTlRfRVZFTlQpKVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVXRpbGl0eSB0byB0cnkgdG8gcHVsbCBhIGtleSBvdXQgb2YgYW4gZWxlbWVudC5cbiAqIFVzZXMgJ2RhdGEta2V5JyBpZiBwb3NzaWJsZSBhbmQgZmFsbHMgYmFjayB0byAnaWQnLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUga2V5IGZvci5cbiAqIEByZXR1cm4ge3N0cmluZ3x2b2lkfVxuICovXG5mdW5jdGlvbiBnZXRLZXkgKG5vZGUpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IEVMRU1FTlRfVFlQRSkgcmV0dXJuXG4gIHZhciBrZXkgPSBub2RlLmdldEF0dHJpYnV0ZShzZXRET00uS0VZKSB8fCBub2RlLmlkXG4gIGlmIChrZXkpIHJldHVybiBLRVlfUFJFRklYICsga2V5XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVXRpbGl0eSB0byB0cnkgdG8gcHVsbCBhIGNoZWNrc3VtIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQuXG4gKiBVc2VzICdkYXRhLWNoZWNrc3VtJyBvciB1c2VyIHNwZWNpZmllZCBjaGVja3N1bSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBnZXQgdGhlIGNoZWNrc3VtIGZvci5cbiAqIEByZXR1cm4ge3N0cmluZ3xOYU59XG4gKi9cbmZ1bmN0aW9uIGdldENoZWNrU3VtIChub2RlKSB7XG4gIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShzZXRET00uQ0hFQ0tTVU0pIHx8IE5hTlxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFV0aWxpdHkgdG8gdHJ5IHRvIGNoZWNrIGlmIGFuIGVsZW1lbnQgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGFsZ29yaXRobS5cbiAqIFVzZXMgJ2RhdGEtaWdub3JlJyBvciB1c2VyIHNwZWNpZmllZCBpZ25vcmUgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2sgaWYgaXQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0lnbm9yZWQgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKHNldERPTS5JR05PUkUpICE9IG51bGxcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmlnZ2VyIGFuIGV2ZW50IGZvciBhIG5vZGUgYW5kIGl0J3MgY2hpbGRyZW4uXG4gKiBPbmx5IGVtaXRzIGV2ZW50cyBmb3Iga2V5ZWQgbm9kZXMuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gdGhlIGluaXRpYWwgbm9kZS5cbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoIChub2RlLCB0eXBlKSB7XG4gIC8vIFRyaWdnZXIgZXZlbnQgZm9yIHRoaXMgZWxlbWVudCBpZiBpdCBoYXMgYSBrZXkuXG4gIGlmIChnZXRLZXkobm9kZSkpIHtcbiAgICB2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAgIHZhciBwcm9wID0geyB2YWx1ZTogbm9kZSB9XG4gICAgZXYuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSlcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXYsICd0YXJnZXQnLCBwcm9wKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldiwgJ3NyY0VsZW1lbnQnLCBwcm9wKVxuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldilcbiAgfVxuXG4gIC8vIERpc3BhdGNoIHRvIGFsbCBjaGlsZHJlbi5cbiAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkXG4gIHdoaWxlIChjaGlsZCkgY2hpbGQgPSBkaXNwYXRjaChjaGlsZCwgdHlwZSkubmV4dFNpYmxpbmdcbiAgcmV0dXJuIG5vZGVcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBDb25maXJtIHRoYXQgYSB2YWx1ZSBpcyB0cnV0aHksIHRocm93cyBhbiBlcnJvciBtZXNzYWdlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCAtIHRoZSB2YWwgdG8gdGVzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgLSB0aGUgZXJyb3IgbWVzc2FnZSBvbiBmYWlsdXJlLlxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcignc2V0LWRvbTogJyArIG1zZylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcGFyc2VyID0gd2luZG93LkRPTVBhcnNlciAmJiBuZXcgd2luZG93LkRPTVBhcnNlcigpXG52YXIgZG9jdW1lbnRSb290TmFtZSA9ICdIVE1MJ1xudmFyIHN1cHBvcnRzSFRNTFR5cGUgPSBmYWxzZVxudmFyIHN1cHBvcnRzSW5uZXJIVE1MID0gZmFsc2VcbnZhciBodG1sVHlwZSA9ICd0ZXh0L2h0bWwnXG52YXIgeGh0bWxUeXBlID0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCdcbnZhciB0ZXN0Q29kZSA9ICc8YnIvPidcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IEZhaWxzIGluIG9sZGVyIGJyb3dzZXJzICovXG50cnkge1xuICAvLyBDaGVjayBpZiBicm93c2VyIHN1cHBvcnRzIHRleHQvaHRtbCBET01QYXJzZXJcbiAgaWYgKHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGVzdENvZGUsIGh0bWxUeXBlKSkgc3VwcG9ydHNIVE1MVHlwZSA9IHRydWVcbn0gY2F0Y2ggKGUpIHtcbiAgdmFyIG1vY2tEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpXG4gIHZhciBtb2NrSFRNTCA9IG1vY2tEb2MuZG9jdW1lbnRFbGVtZW50XG4gIHZhciBtb2NrQm9keSA9IG1vY2tEb2MuYm9keVxuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydHMgZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTFxuICAgIG1vY2tIVE1MLmlubmVySFRNTCArPSAnJ1xuICAgIHN1cHBvcnRzSW5uZXJIVE1MID0gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0cyB4aHRtbCBwYXJzaW5nLlxuICAgIHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGVzdENvZGUsIHhodG1sVHlwZSlcbiAgICB2YXIgYm9keVJlZyA9IC8oPGJvZHlbXj5dKj4pKFtcXHNcXFNdKik8XFwvYm9keT4vXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGEgRE9NUGFyc2VyIGFzIGFuIEhUTUxFbGVtZW50LlxuICogKFNoaW1zIGZvciBvbGRlciBicm93c2VycykuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNIVE1MVHlwZVxuICA/IGZ1bmN0aW9uIHBhcnNlSFRNTCAobWFya3VwLCByb290TmFtZSkge1xuICAgIHZhciBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKG1hcmt1cCwgaHRtbFR5cGUpXG4gICAgcmV0dXJuIHJvb3ROYW1lID09PSBkb2N1bWVudFJvb3ROYW1lXG4gICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnRcbiAgICAgIDogZG9jLmJvZHkuZmlyc3RDaGlsZFxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBPbmx5IHVzZWQgaW4gb2xkZXIgYnJvd3NlcnMgKi9cbiAgOiBmdW5jdGlvbiBwYXJzZUhUTUwgKG1hcmt1cCwgcm9vdE5hbWUpIHtcbiAgICAvLyBGYWxsYmFjayB0byBpbm5lckhUTUwgZm9yIG90aGVyIG9sZGVyIGJyb3dzZXJzLlxuICAgIGlmIChyb290TmFtZSA9PT0gZG9jdW1lbnRSb290TmFtZSkge1xuICAgICAgaWYgKHN1cHBvcnRzSW5uZXJIVE1MKSB7XG4gICAgICAgIG1vY2tIVE1MLmlubmVySFRNTCA9IG1hcmt1cFxuICAgICAgICByZXR1cm4gbW9ja0hUTUxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElFOSBkb2VzIG5vdCBzdXBwb3J0IGlubmVyaHRtbCBhdCByb290IGxldmVsLlxuICAgICAgICAvLyBXZSBnZXQgYXJvdW5kIHRoaXMgYnkgcGFyc2luZyBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgYm9keSBhcyB4aHRtbC5cbiAgICAgICAgdmFyIGJvZHlNYXRjaCA9IG1hcmt1cC5tYXRjaChib2R5UmVnKVxuICAgICAgICBpZiAoYm9keU1hdGNoKSB7XG4gICAgICAgICAgdmFyIGJvZHlDb250ZW50ID0gYm9keU1hdGNoWzJdXG4gICAgICAgICAgdmFyIHN0YXJ0Qm9keSA9IGJvZHlNYXRjaC5pbmRleCArIGJvZHlNYXRjaFsxXS5sZW5ndGhcbiAgICAgICAgICB2YXIgZW5kQm9keSA9IHN0YXJ0Qm9keSArIGJvZHlDb250ZW50Lmxlbmd0aFxuICAgICAgICAgIG1hcmt1cCA9IG1hcmt1cC5zbGljZSgwLCBzdGFydEJvZHkpICsgbWFya3VwLnNsaWNlKGVuZEJvZHkpXG4gICAgICAgICAgbW9ja0JvZHkuaW5uZXJIVE1MID0gYm9keUNvbnRlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKG1hcmt1cCwgeGh0bWxUeXBlKVxuICAgICAgICB2YXIgYm9keSA9IGRvYy5ib2R5XG4gICAgICAgIHdoaWxlIChtb2NrQm9keS5maXJzdENoaWxkKSBib2R5LmFwcGVuZENoaWxkKG1vY2tCb2R5LmZpcnN0Q2hpbGQpXG4gICAgICAgIHJldHVybiBkb2MuZG9jdW1lbnRFbGVtZW50XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vY2tCb2R5LmlubmVySFRNTCA9IG1hcmt1cFxuICAgICAgcmV0dXJuIG1vY2tCb2R5LmZpcnN0Q2hpbGRcbiAgICB9XG4gIH1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dG9yID0gcmVxdWlyZSgnLi9leGVjdXRvcicpO1xuXG5mdW5jdGlvbiBCZW5jaG1hcmsoKSB7XG4gIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICB0aGlzLmltcGwgPSBudWxsO1xuICB0aGlzLnRlc3RzID0gbnVsbDtcbiAgdGhpcy5yZXBvcnRDYWxsYmFjayA9IG51bGw7XG4gIHRoaXMuZW5hYmxlVGVzdHMgPSBmYWxzZTtcblxuICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHRoaXMuX3J1bkJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdSdW5CdXR0b24nKTtcbiAgdGhpcy5faXRlcmF0aW9uc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnSXRlcmF0aW9ucycpO1xuICB0aGlzLl9yZXBvcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncHJlJyk7XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fcmVwb3J0RWxlbWVudCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX3J1bkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAoIXNlbGYucnVubmluZykge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBwYXJzZUludChzZWxmLl9pdGVyYXRpb25zRWxlbWVudC52YWx1ZSk7XG4gICAgICBpZiAoaXRlcmF0aW9ucyA8PSAwKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgIH1cblxuICAgICAgc2VsZi5ydW4oaXRlcmF0aW9ucyk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG5cbiAgdGhpcy5yZWFkeSh0cnVlKTtcbn1cblxuQmVuY2htYXJrLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHYpIHtcbiAgICB0aGlzLl9ydW5CdXR0b24uZGlzYWJsZWQgPSAnJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ydW5CdXR0b24uZGlzYWJsZWQgPSAndHJ1ZSc7XG4gIH1cbn07XG5cbkJlbmNobWFyay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oaXRlcmF0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucnVubmluZyA9IHRydWU7XG4gIHRoaXMucmVhZHkoZmFsc2UpO1xuXG4gIG5ldyBFeGVjdXRvcihzZWxmLmltcGwsIHNlbGYuY29udGFpbmVyLCBzZWxmLnRlc3RzLCAxLCBmdW5jdGlvbigpIHsgLy8gd2FybXVwXG4gICAgbmV3IEV4ZWN1dG9yKHNlbGYuaW1wbCwgc2VsZi5jb250YWluZXIsIHNlbGYudGVzdHMsIGl0ZXJhdGlvbnMsIGZ1bmN0aW9uKHNhbXBsZXMpIHtcbiAgICAgIHNlbGYuX3JlcG9ydEVsZW1lbnQudGV4dENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShzYW1wbGVzLCBudWxsLCAnICcpO1xuICAgICAgc2VsZi5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnJlYWR5KHRydWUpO1xuICAgICAgaWYgKHNlbGYucmVwb3J0Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZWxmLnJlcG9ydENhbGxiYWNrKHNhbXBsZXMpO1xuICAgICAgfVxuICAgIH0sIHVuZGVmaW5lZCwgZmFsc2UpLnN0YXJ0KCk7XG4gIH0sIHVuZGVmaW5lZCwgdGhpcy5lbmFibGVUZXN0cykuc3RhcnQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVuY2htYXJrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZW5kZXIobm9kZXMpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIHZhciBqO1xuICB2YXIgYztcbiAgdmFyIGk7XG4gIHZhciBlO1xuICB2YXIgbjtcblxuICBmb3IgKGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBuID0gbm9kZXNbaV07XG4gICAgaWYgKG4uY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGMgPSByZW5kZXIobi5jaGlsZHJlbik7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgICBlLmFwcGVuZENoaWxkKGNbal0pO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucHVzaChlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIGUudGV4dENvbnRlbnQgPSBuLmtleS50b1N0cmluZygpO1xuICAgICAgY2hpbGRyZW4ucHVzaChlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHRlc3RJbm5lckh0bWwodGVzdE5hbWUsIG5vZGVzLCBjb250YWluZXIpIHtcbiAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIGNoaWxkcmVuID0gcmVuZGVyKG5vZGVzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGUuYXBwZW5kQ2hpbGQoY2hpbGRyZW5baV0pO1xuICB9XG4gIGMuYXBwZW5kQ2hpbGQoZSk7XG4gIGlmIChjLmlubmVySFRNTCAhPT0gY29udGFpbmVyLmlubmVySFRNTCkge1xuICAgIGNvbnNvbGUubG9nKCdlcnJvciBpbiB0ZXN0OiAnICsgdGVzdE5hbWUpO1xuICAgIGNvbnNvbGUubG9nKCdjb250YWluZXIuaW5uZXJIVE1MOicpO1xuICAgIGNvbnNvbGUubG9nKGNvbnRhaW5lci5pbm5lckhUTUwpO1xuICAgIGNvbnNvbGUubG9nKCdzaG91bGQgYmU6Jyk7XG4gICAgY29uc29sZS5sb2coYy5pbm5lckhUTUwpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gRXhlY3V0b3IoaW1wbCwgY29udGFpbmVyLCB0ZXN0cywgaXRlcmF0aW9ucywgY2IsIGl0ZXJDYiwgZW5hYmxlVGVzdHMpIHtcbiAgaWYgKGl0ZXJDYiA9PT0gdm9pZCAwKSBpdGVyQ2IgPSBudWxsO1xuXG4gIHRoaXMuaW1wbCA9IGltcGw7XG4gIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICB0aGlzLnRlc3RzID0gdGVzdHM7XG4gIHRoaXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pdGVyQ2IgPSBpdGVyQ2I7XG4gIHRoaXMuZW5hYmxlVGVzdHMgPSBlbmFibGVUZXN0cztcblxuICB0aGlzLl9jdXJyZW50VGVzdCA9IDA7XG4gIHRoaXMuX2N1cnJlbnRJdGVyID0gMDtcbiAgdGhpcy5fcmVuZGVyU2FtcGxlcyA9IFtdO1xuICB0aGlzLl91cGRhdGVTYW1wbGVzID0gW107XG4gIHRoaXMuX3Jlc3VsdCA9IFtdO1xuXG4gIHRoaXMuX3Rhc2tzQ291bnQgPSB0ZXN0cy5sZW5ndGggKiBpdGVyYXRpb25zO1xuXG4gIHRoaXMuX2l0ZXIgPSB0aGlzLml0ZXIuYmluZCh0aGlzKTtcbn1cblxuRXhlY3V0b3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2l0ZXIoKTtcbn07XG5cbkV4ZWN1dG9yLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNiKHRoaXMuX3Jlc3VsdCk7XG59O1xuXG5FeGVjdXRvci5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2N1cnJlbnRUZXN0ID09PSAwICYmIHRoaXMuX2N1cnJlbnRJdGVyID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgdGVzdHMgPSB0aGlzLnRlc3RzO1xuICByZXR1cm4gKHRoaXMuX2N1cnJlbnRUZXN0ICogdGVzdHMubGVuZ3RoICsgdGhpcy5fY3VycmVudEl0ZXIpIC8gKHRlc3RzLmxlbmd0aCAqIHRoaXMuaXRlcmF0YWlvbnMpO1xufTtcblxuRXhlY3V0b3IucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXRlckNiICE9IG51bGwpIHtcbiAgICB0aGlzLml0ZXJDYih0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXN0cyA9IHRoaXMudGVzdHM7XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnRUZXN0IDwgdGVzdHMubGVuZ3RoKSB7XG4gICAgdmFyIHRlc3QgPSB0ZXN0c1t0aGlzLl9jdXJyZW50VGVzdF07XG5cbiAgICBpZiAodGhpcy5fY3VycmVudEl0ZXIgPCB0aGlzLml0ZXJhdGlvbnMpIHtcbiAgICAgIHZhciBlLCB0O1xuICAgICAgdmFyIHJlbmRlclRpbWUsIHVwZGF0ZVRpbWU7XG5cbiAgICAgIGUgPSBuZXcgdGhpcy5pbXBsKHRoaXMuY29udGFpbmVyLCB0ZXN0LmRhdGEuYSwgdGVzdC5kYXRhLmIpO1xuICAgICAgZS5zZXRVcCgpO1xuXG4gICAgICB0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgZS5yZW5kZXIoKTtcbiAgICAgIHJlbmRlclRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuXG4gICAgICBpZiAodGhpcy5lbmFibGVUZXN0cykge1xuICAgICAgICB0ZXN0SW5uZXJIdG1sKHRlc3QubmFtZSArICdyZW5kZXIoKScsIHRlc3QuZGF0YS5hLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIHQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBlLnVwZGF0ZSgpO1xuICAgICAgdXBkYXRlVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZVRlc3RzKSB7XG4gICAgICAgIHRlc3RJbm5lckh0bWwodGVzdC5uYW1lICsgJ3VwZGF0ZSgpJywgdGVzdC5kYXRhLmIsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgICAgZS50ZWFyRG93bigpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJTYW1wbGVzLnB1c2gocmVuZGVyVGltZSk7XG4gICAgICB0aGlzLl91cGRhdGVTYW1wbGVzLnB1c2godXBkYXRlVGltZSk7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRJdGVyKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc3VsdC5wdXNoKHtcbiAgICAgICAgbmFtZTogdGVzdC5uYW1lICsgJyAnICsgJ3JlbmRlcigpJyxcbiAgICAgICAgZGF0YTogdGhpcy5fcmVuZGVyU2FtcGxlcy5zbGljZSgwKVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdC5wdXNoKHtcbiAgICAgICAgbmFtZTogdGVzdC5uYW1lICsgJyAnICsgJ3VwZGF0ZSgpJyxcbiAgICAgICAgZGF0YTogdGhpcy5fdXBkYXRlU2FtcGxlcy5zbGljZSgwKVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRUZXN0Kys7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRJdGVyID0gMDtcbiAgICAgIHRoaXMuX3JlbmRlclNhbXBsZXMgPSBbXTtcbiAgICAgIHRoaXMuX3VwZGF0ZVNhbXBsZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KHRoaXMuX2l0ZXIsIDApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluaXNoZWQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJlbmNobWFyayA9IHJlcXVpcmUoJy4vYmVuY2htYXJrJyk7XG52YXIgYmVuY2htYXJrID0gbmV3IEJlbmNobWFyaygpO1xuXG5mdW5jdGlvbiBpbml0RnJvbVNjcmlwdChzY3JpcHRVcmwsIGltcGwpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgZS5zcmMgPSBzY3JpcHRVcmw7XG5cbiAgZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBiZW5jaG1hcmsudGVzdHMgPSB3aW5kb3cuZ2VuZXJhdGVCZW5jaG1hcmtEYXRhKCkudW5pdHM7XG4gICAgYmVuY2htYXJrLnJlYWR5KHRydWUpO1xuICB9O1xuXG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSk7XG59XG5cbmZ1bmN0aW9uIGluaXRGcm9tUGFyZW50V2luZG93KHBhcmVudCwgbmFtZSwgdmVyc2lvbiwgaWQpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGRhdGEgPSBlLmRhdGE7XG4gICAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3Rlc3RzJykge1xuICAgICAgYmVuY2htYXJrLnRlc3RzID0gZGF0YS5kYXRhO1xuICAgICAgYmVuY2htYXJrLnJlcG9ydENhbGxiYWNrID0gZnVuY3Rpb24oc2FtcGxlcykge1xuICAgICAgICBwYXJlbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6ICdyZXBvcnQnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgc2FtcGxlczogc2FtcGxlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH0sICcqJyk7XG4gICAgICB9O1xuICAgICAgYmVuY2htYXJrLnJlYWR5KHRydWUpO1xuXG4gICAgICBwYXJlbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAncmVhZHknLFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBpZDogaWRcbiAgICAgIH0sICcqJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAncnVuJykge1xuICAgICAgYmVuY2htYXJrLnJ1bihkYXRhLmRhdGEuaXRlcmF0aW9ucyk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG5cbiAgcGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICB0eXBlOiAnaW5pdCcsXG4gICAgZGF0YTogbnVsbCxcbiAgICBpZDogaWRcbiAgfSwgJyonKTtcbn1cblxuZnVuY3Rpb24gaW5pdChuYW1lLCB2ZXJzaW9uLCBpbXBsKSB7XG4gIC8vIFBhcnNlIFF1ZXJ5IFN0cmluZy5cbiAgdmFyIHFzID0gKGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoYSA9PSBcIlwiKSByZXR1cm4ge307XG4gICAgdmFyIGIgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBwPWFbaV0uc3BsaXQoJz0nLCAyKTtcbiAgICAgIGlmIChwLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGJbcFswXV0gPSBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYltwWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwWzFdLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYjtcbiAgfSkod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkuc3BsaXQoJyYnKSk7XG5cbiAgaWYgKHFzWyduYW1lJ10gIT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSBxc1snbmFtZSddO1xuICB9XG5cbiAgaWYgKHFzWyd2ZXJzaW9uJ10gIT09IHZvaWQgMCkge1xuICAgIHZlcnNpb24gPSBxc1sndmVyc2lvbiddO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBxc1sndHlwZSddO1xuXG4gIGlmIChxc1sndGVzdCddICE9PSB2b2lkIDApIHtcbiAgICBiZW5jaG1hcmsuZW5hYmxlVGVzdHMgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKCd0ZXN0cyBlbmFibGVkJyk7XG4gIH1cblxuICB2YXIgaWQ7XG4gIGlmICh0eXBlID09PSAnaWZyYW1lJykge1xuICAgIGlkID0gcXNbJ2lkJ107XG4gICAgaWYgKGlkID09PSB2b2lkIDApIGlkID0gbnVsbDtcbiAgICBpbml0RnJvbVBhcmVudFdpbmRvdyh3aW5kb3cucGFyZW50LCBuYW1lLCB2ZXJzaW9uLCBpZCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3dpbmRvdycpIHtcbiAgICBpZiAod2luZG93Lm9wZW5lciAhPSBudWxsKSB7XG4gICAgICBpZCA9IHFzWydpZCddO1xuICAgICAgaWYgKGlkID09PSB2b2lkIDApIGlkID0gbnVsbDtcbiAgICAgIGluaXRGcm9tUGFyZW50V2luZG93KHdpbmRvdy5vcGVuZXIsIG5hbWUsIHZlcnNpb24sIGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBpbml0aWFsaXplOiBvcGVuZXIgd2luZG93IGlzIE5VTEwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRlc3RzVXJsID0gcXNbJ2RhdGEnXTsgLy8gdXJsIHRvIHRoZSBzY3JpcHQgZ2VuZXJhdGluZyB0ZXN0IGRhdGFcbiAgICBpZiAodGVzdHNVcmwgIT09IHZvaWQgMCkge1xuICAgICAgaW5pdEZyb21TY3JpcHQodGVzdHNVcmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGluaXRpYWxpemU6IGNhbm5vdCBsb2FkIHRlc3RzIGRhdGEnKTtcbiAgICB9XG4gIH1cblxuICBiZW5jaG1hcmsuaW1wbCA9IGltcGw7XG59XG5cbi8vIHBlcmZvcm1hbmNlLm5vdygpIHBvbHlmaWxsXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNTQzODY1MFxuLy8gcHJlcGFyZSBiYXNlIHBlcmYgb2JqZWN0XG5pZiAodHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XG59XG5pZiAoIXdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpe1xuICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcbiAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSB7XG4gICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgfVxuICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdDtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJwcml2YXRlXCI6IHRydWUsXG4gIFwibmFtZVwiOiBcInZkb20tYmVuY2htYXJrLXNldC1kb21cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4yLjBcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlZpcnR1YWwgRE9NIEJlbmNobWFyazogc2V0LWRvbVwiLFxuICBcImxpY2Vuc2VcIjogXCJCU0RcIixcbiAgXCJyZXBvc2l0b3J5XCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2xvY2Fsdm9pZC92ZG9tLWJlbmNobWFyay1zZXQtZG9tXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJCb3JpcyBLYXVsXCIsXG4gICAgXCJlbWFpbFwiOiBcImxvY2Fsdm9pZEBnbWFpbC5jb21cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9sb2NhbHZvaWRcIlxuICB9LFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcInZpcnR1YWxcIixcbiAgICBcImRvbVwiLFxuICAgIFwidmlydHVhbGRvbVwiLFxuICAgIFwidmRvbVwiLFxuICAgIFwiZGlmZlwiLFxuICAgIFwiYnJvd3NlclwiLFxuICAgIFwiYmVuY2htYXJrXCIsXG4gICAgXCJ2ZG9tLWJlbmNobWFya1wiXG4gIF0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImVudmlmeVwiOiBcIn40LjAuMFwiLFxuICAgIFwic2V0LWRvbVwiOiBcIl43LjMuM1wiLFxuICAgIFwidmRvbS1iZW5jaG1hcmstYmFzZVwiOiBcIn4wLjIuNFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXItc3luY1wiOiBcIl4yLjE4LjhcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTQuMS4wXCIsXG4gICAgXCJkZWxcIjogXCJeMi4yLjJcIixcbiAgICBcImd1bHBcIjogXCJeMy45LjFcIixcbiAgICBcImd1bHAtZ2gtcGFnZXNcIjogXCJ+MC41LjRcIixcbiAgICBcImd1bHAtaWZcIjogXCJeMi4wLjJcIixcbiAgICBcImd1bHAtc291cmNlbWFwc1wiOiBcIl4yLjQuMVwiLFxuICAgIFwiZ3VscC11Z2xpZnlcIjogXCJeMi4xLjJcIixcbiAgICBcInZpbnlsLWJ1ZmZlclwiOiBcIl4xLjAuMFwiLFxuICAgIFwidmlueWwtc291cmNlLXN0cmVhbVwiOiBcIl4xLjEuMFwiXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYmVuY2htYXJrID0gcmVxdWlyZSgndmRvbS1iZW5jaG1hcmstYmFzZScpXG52YXIgc2V0RE9NID0gcmVxdWlyZSgnc2V0LWRvbScpXG5cbnZhciBOQU1FID0gJ3NldC1kb20nXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLmRlcGVuZGVuY2llc1snc2V0LWRvbSddXG5cbmZ1bmN0aW9uIHJlbmRlclRyZWUgKG5vZGVzLCBwYXJlbnQsIGRlcHRoKSB7XG4gIHZhciBlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldXG4gICAgaWYgKG4uY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZS5pZCA9ICcnICsgZGVwdGggKyAnXycgKyBuLmtleVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGUpXG4gICAgICByZW5kZXJUcmVlKG4uY2hpbGRyZW4sIGUsIGRlcHRoICsgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgZS5pZCA9ICcnICsgZGVwdGggKyAnXycgKyBuLmtleVxuICAgICAgZS50ZXh0Q29udGVudCA9IG4ua2V5XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmVuY2htYXJrSW1wbCAoY29udGFpbmVyLCBhLCBiKSB7XG4gIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyXG4gIHRoaXMuYSA9IGFcbiAgdGhpcy5iID0gYlxuICB0aGlzLl9yb290ID0gbnVsbFxufVxuXG5CZW5jaG1hcmtJbXBsLnByb3RvdHlwZS5zZXRVcCA9IGZ1bmN0aW9uICgpIHt9XG5cbkJlbmNobWFya0ltcGwucHJvdG90eXBlLnRlYXJEb3duID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lci5maXJzdENoaWxkKVxufVxuXG5CZW5jaG1hcmtJbXBsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICByZW5kZXJUcmVlKHRoaXMuYSwgdGhpcy5fcm9vdCwgMClcbiAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdClcbn1cblxuQmVuY2htYXJrSW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHJlbmRlclRyZWUodGhpcy5iLCBlLCAwKVxuICBzZXRET00odGhpcy5fcm9vdCwgZSlcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIChlKSB7XG4gIGJlbmNobWFyayhOQU1FLCBWRVJTSU9OLCBCZW5jaG1hcmtJbXBsKVxufSwgZmFsc2UpXG4iXX0="}