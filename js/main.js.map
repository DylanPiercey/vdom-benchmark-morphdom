{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/set-dom/src/index.js","node_modules/set-dom/src/parse-html.js","node_modules/vdom-benchmark-base/lib/benchmark.js","node_modules/vdom-benchmark-base/lib/executor.js","node_modules/vdom-benchmark-base/lib/index.js","web/js/main.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict'\n\nsetDOM.KEY = 'data-key'\nsetDOM.IGNORE = 'data-ignore'\nsetDOM.CHECKSUM = 'data-checksum'\nvar parseHTML = require('./parse-html')\nvar KEY_PREFIX = '_set-dom-'\nvar NODE_MOUNTED = KEY_PREFIX + 'mounted'\nvar MOUNT_EVENT = 'mount'\nvar DISMOUNT_EVENT = 'dismount'\nvar ELEMENT_TYPE = 1\nvar DOCUMENT_TYPE = 9\nvar DOCUMENT_FRAGMENT_TYPE = 11\n\n// Expose api.\nmodule.exports = setDOM\n\n/**\n * @description\n * Updates existing dom to match a new dom.\n *\n * @param {Node} oldNode - The html entity to update.\n * @param {String|Node} newNode - The updated html(entity).\n */\nfunction setDOM (oldNode, newNode) {\n  // Ensure a realish dom node is provided.\n  assert(oldNode && oldNode.nodeType, 'You must provide a valid node to update.')\n\n  // Alias document element with document.\n  if (oldNode.nodeType === DOCUMENT_TYPE) oldNode = oldNode.documentElement\n\n  // Document Fragments don't have attributes, so no need to look at checksums, ignored, attributes, or node replacement.\n  if (newNode.nodeType === DOCUMENT_FRAGMENT_TYPE) {\n    // Simply update all children (and subchildren).\n    setChildNodes(oldNode, newNode)\n  } else {\n    // Otherwise we diff the entire old node.\n    setNode(oldNode, typeof newNode === 'string'\n      // If a string was provided we will parse it as dom.\n      ? parseHTML(newNode, oldNode.nodeName)\n      : newNode\n    )\n  }\n\n  // Trigger mount events on initial set.\n  if (!oldNode[NODE_MOUNTED]) {\n    oldNode[NODE_MOUNTED] = true\n    dispatch(oldNode, MOUNT_EVENT)\n  }\n}\n\n/**\n * @private\n * @description\n * Updates a specific htmlNode and does whatever it takes to convert it to another one.\n *\n * @param {Node} oldNode - The previous HTMLNode.\n * @param {Node} newNode - The updated HTMLNode.\n */\nfunction setNode (oldNode, newNode) {\n  if (oldNode.nodeType === newNode.nodeType) {\n    // Handle regular element node updates.\n    if (oldNode.nodeType === ELEMENT_TYPE) {\n      // Checks if nodes are equal before diffing.\n      if (isEqualNode(oldNode, newNode)) return\n\n      // Update all children (and subchildren).\n      setChildNodes(oldNode, newNode)\n\n      // Update the elements attributes / tagName.\n      if (oldNode.nodeName === newNode.nodeName) {\n        // If we have the same nodename then we can directly update the attributes.\n        setAttributes(oldNode.attributes, newNode.attributes)\n      } else {\n        // Otherwise clone the new node to use as the existing node.\n        var newPrev = newNode.cloneNode()\n        // Copy over all existing children from the original node.\n        while (oldNode.firstChild) newPrev.appendChild(oldNode.firstChild)\n        // Replace the original node with the new one with the right tag.\n        oldNode.parentNode.replaceChild(newPrev, oldNode)\n      }\n    } else {\n      // Handle other types of node updates (text/comments/etc).\n      // If both are the same type of node we can update directly.\n      if (oldNode.nodeValue !== newNode.nodeValue) {\n        oldNode.nodeValue = newNode.nodeValue\n      }\n    }\n  } else {\n    // we have to replace the node.\n    dispatch(oldNode, DISMOUNT_EVENT)\n    oldNode.parentNode.replaceChild(newNode, oldNode)\n    dispatch(newNode, MOUNT_EVENT)\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will update one list of attributes to match another.\n *\n * @param {NamedNodeMap} oldAttributes - The previous attributes.\n * @param {NamedNodeMap} newAttributes - The updated attributes.\n */\nfunction setAttributes (oldAttributes, newAttributes) {\n  var i, a, b, ns, name\n\n  // Remove old attributes.\n  for (i = oldAttributes.length; i--;) {\n    a = oldAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = newAttributes.getNamedItemNS(ns, name)\n    if (!b) oldAttributes.removeNamedItemNS(ns, name)\n  }\n\n  // Set new attributes.\n  for (i = newAttributes.length; i--;) {\n    a = newAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = oldAttributes.getNamedItemNS(ns, name)\n    if (!b) {\n      // Add a new attribute.\n      newAttributes.removeNamedItemNS(ns, name)\n      oldAttributes.setNamedItemNS(a)\n    } else if (b.value !== a.value) {\n      // Update existing attribute.\n      b.value = a.value\n    }\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will nodes childern to match another nodes children.\n *\n * @param {Node} oldParent - The existing parent node.\n * @param {Node} newParent - The new parent node.\n */\nfunction setChildNodes (oldParent, newParent) {\n  var checkOld, oldKey, checkNew, newKey, foundNode, keyedNodes\n  var oldNode = oldParent.firstChild\n  var newNode = newParent.firstChild\n  var extra = 0\n\n  // Extract keyed nodes from previous children and keep track of total count.\n  while (oldNode) {\n    extra++\n    checkOld = oldNode\n    oldKey = getKey(checkOld)\n    oldNode = oldNode.nextSibling\n\n    if (oldKey) {\n      if (!keyedNodes) keyedNodes = {}\n      keyedNodes[oldKey] = checkOld\n    }\n  }\n\n  // Loop over new nodes and perform updates.\n  oldNode = oldParent.firstChild\n  while (newNode) {\n    extra--\n    checkNew = newNode\n    newNode = newNode.nextSibling\n\n    if (keyedNodes && (newKey = getKey(checkNew)) && (foundNode = keyedNodes[newKey])) {\n      delete keyedNodes[newKey]\n      // If we have a key and it existed before we move the previous node to the new position if needed and diff it.\n      if (foundNode !== oldNode) {\n        oldParent.insertBefore(foundNode, oldNode)\n      } else {\n        oldNode = oldNode.nextSibling\n      }\n\n      setNode(foundNode, checkNew)\n    } else if (oldNode) {\n      checkOld = oldNode\n      oldNode = oldNode.nextSibling\n      if (getKey(checkOld)) {\n        // If the old child had a key we skip over it until the end.\n        oldParent.insertBefore(checkNew, checkOld)\n        dispatch(checkNew, MOUNT_EVENT)\n      } else {\n        // Otherwise we diff the two non-keyed nodes.\n        setNode(checkOld, checkNew)\n      }\n    } else {\n      // Finally if there was no old node we add the new node.\n      oldParent.appendChild(checkNew)\n      dispatch(checkNew, MOUNT_EVENT)\n    }\n  }\n\n  // Remove old keyed nodes.\n  for (oldKey in keyedNodes) {\n    extra--\n    oldParent.removeChild(keyedNodes[oldKey])\n  }\n\n  // If we have any remaining unkeyed nodes remove them from the end.\n  while (--extra >= 0) {\n    oldParent.removeChild(dispatch(oldParent.lastChild, DISMOUNT_EVENT))\n  }\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a key out of an element.\n * Uses 'data-key' if possible and falls back to 'id'.\n *\n * @param {Node} node - The node to get the key for.\n * @return {string|void}\n */\nfunction getKey (node) {\n  if (node.nodeType !== ELEMENT_TYPE) return\n  var key = node.getAttribute(setDOM.KEY) || node.id\n  if (key) return KEY_PREFIX + key\n}\n\n/**\n * Checks if nodes are equal using the following by checking if\n * they are both ignored, have the same checksum, or have the\n * same contents.\n *\n * @param {Node} a - One of the nodes to compare.\n * @param {Node} b - Another node to compare.\n */\nfunction isEqualNode (a, b) {\n  return (\n    // Check if both nodes are ignored.\n    (isIgnored(a) && isIgnored(b)) ||\n    // Check if both nodes have the same checksum.\n    (getCheckSum(a) === getCheckSum(b)) ||\n    // Fall back to native isEqualNode check.\n    a.isEqualNode(b)\n  )\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a checksum attribute from an element.\n * Uses 'data-checksum' or user specified checksum property.\n *\n * @param {Node} node - The node to get the checksum for.\n * @return {string|NaN}\n */\nfunction getCheckSum (node) {\n  return node.getAttribute(setDOM.CHECKSUM) || NaN\n}\n\n/**\n * @private\n * @description\n * Utility to try to check if an element should be ignored by the algorithm.\n * Uses 'data-ignore' or user specified ignore property.\n *\n * @param {Node} node - The node to check if it should be ignored.\n * @return {boolean}\n */\nfunction isIgnored (node) {\n  return node.getAttribute(setDOM.IGNORE) != null\n}\n\n/**\n * Recursively trigger an event for a node and it's children.\n * Only emits events for keyed nodes.\n *\n * @param {Node} node - the initial node.\n * @return {Node}\n */\nfunction dispatch (node, type) {\n  // Trigger event for this element if it has a key.\n  if (getKey(node)) {\n    var ev = document.createEvent('Event')\n    var prop = { value: node }\n    ev.initEvent(type, false, false)\n    Object.defineProperty(ev, 'target', prop)\n    Object.defineProperty(ev, 'srcElement', prop)\n    node.dispatchEvent(ev)\n  }\n\n  // Dispatch to all children.\n  var child = node.firstChild\n  while (child) child = dispatch(child, type).nextSibling\n  return node\n}\n\n/**\n * @private\n * @description\n * Confirm that a value is truthy, throws an error message otherwise.\n *\n * @param {*} val - the val to test.\n * @param {string} msg - the error message on failure.\n * @throws {Error}\n */\nfunction assert (val, msg) {\n  if (!val) throw new Error('set-dom: ' + msg)\n}\n","'use strict'\n\nvar parser = window.DOMParser && new window.DOMParser()\nvar documentRootName = 'HTML'\nvar supportsHTMLType = false\nvar supportsInnerHTML = false\nvar htmlType = 'text/html'\nvar xhtmlType = 'application/xhtml+xml'\nvar testCode = '<br/>'\n\n/* istanbul ignore next: Fails in older browsers */\ntry {\n  // Check if browser supports text/html DOMParser\n  if (parser.parseFromString(testCode, htmlType)) supportsHTMLType = true\n} catch (e) {\n  var mockDoc = document.implementation.createHTMLDocument('')\n  var mockHTML = mockDoc.documentElement\n  var mockBody = mockDoc.body\n  try {\n    // Check if browser supports documentElement.innerHTML\n    mockHTML.innerHTML += ''\n    supportsInnerHTML = true\n  } catch (e) {\n    // Check if browser supports xhtml parsing.\n    parser.parseFromString(testCode, xhtmlType)\n    var bodyReg = /(<body[^>]*>)([\\s\\S]*)<\\/body>/\n  }\n}\n\n/**\n * Returns the results of a DOMParser as an HTMLElement.\n * (Shims for older browsers).\n */\nmodule.exports = supportsHTMLType\n  ? function parseHTML (markup, rootName) {\n    var doc = parser.parseFromString(markup, htmlType)\n    return rootName === documentRootName\n      ? doc.documentElement\n      : doc.body.firstChild\n  }\n  /* istanbul ignore next: Only used in older browsers */\n  : function parseHTML (markup, rootName) {\n    // Fallback to innerHTML for other older browsers.\n    if (rootName === documentRootName) {\n      if (supportsInnerHTML) {\n        mockHTML.innerHTML = markup\n        return mockHTML\n      } else {\n        // IE9 does not support innerhtml at root level.\n        // We get around this by parsing everything except the body as xhtml.\n        var bodyMatch = markup.match(bodyReg)\n        if (bodyMatch) {\n          var bodyContent = bodyMatch[2]\n          var startBody = bodyMatch.index + bodyMatch[1].length\n          var endBody = startBody + bodyContent.length\n          markup = markup.slice(0, startBody) + markup.slice(endBody)\n          mockBody.innerHTML = bodyContent\n        }\n\n        var doc = parser.parseFromString(markup, xhtmlType)\n        var body = doc.body\n        while (mockBody.firstChild) body.appendChild(mockBody.firstChild)\n        return doc.documentElement\n      }\n    } else {\n      mockBody.innerHTML = markup\n      return mockBody.firstChild\n    }\n  }\n","'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n  this.enableTests = false;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }, undefined, false).start();\n  }, undefined, this.enableTests).start();\n};\n\nmodule.exports = Benchmark;\n","'use strict';\n\nfunction render(nodes) {\n  var children = [];\n  var j;\n  var c;\n  var i;\n  var e;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      e = document.createElement('div');\n      c = render(n.children);\n      for (j = 0; j < c.length; j++) {\n        e.appendChild(c[j]);\n      }\n      children.push(e);\n    } else {\n      e = document.createElement('span');\n      e.textContent = n.key.toString();\n      children.push(e);\n    }\n  }\n\n  return children;\n}\n\nfunction testInnerHtml(testName, nodes, container) {\n  var c = document.createElement('div');\n  var e = document.createElement('div');\n  var children = render(nodes);\n  for (var i = 0; i < children.length; i++) {\n    e.appendChild(children[i]);\n  }\n  c.appendChild(e);\n  if (c.innerHTML !== container.innerHTML) {\n    console.log('error in test: ' + testName);\n    console.log('container.innerHTML:');\n    console.log(container.innerHTML);\n    console.log('should be:');\n    console.log(c.innerHTML);\n  }\n}\n\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb, enableTests) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n  this.enableTests = enableTests;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'render()', test.data.a, this.container);\n      }\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'update()', test.data.b, this.container);\n      }\n\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n","'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.generateBenchmarkData().units;\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n\n  if (qs['test'] !== void 0) {\n    benchmark.enableTests = true;\n    console.log('tests enabled');\n  }\n\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n","'use strict'\n\nvar benchmark = require('vdom-benchmark-base')\nvar setDOM = require('set-dom')\n\nvar NAME = 'set-dom'\nvar VERSION = '8.0.0'\n\nfunction renderTree (nodes, parent, depth) {\n  var e\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i]\n    if (n.children !== null) {\n      e = document.createElement('div')\n      e.id = '' + depth + '_' + n.key\n      parent.appendChild(e)\n      renderTree(n.children, e, depth + 1)\n    } else {\n      e = document.createElement('span')\n      e.id = '' + depth + '_' + n.key\n      e.textContent = n.key\n      parent.appendChild(e)\n    }\n  }\n}\n\nfunction BenchmarkImpl (container, a, b) {\n  this.container = container\n  this.a = a\n  this.b = b\n  this._root = null\n}\n\nBenchmarkImpl.prototype.setUp = function () {}\n\nBenchmarkImpl.prototype.tearDown = function () {\n  this.container.removeChild(this.container.firstChild)\n}\n\nBenchmarkImpl.prototype.render = function () {\n  this._root = document.createElement('div')\n  renderTree(this.a, this._root, 0)\n  this.container.appendChild(this._root)\n}\n\nBenchmarkImpl.prototype.update = function () {\n  var e = document.createElement('div')\n  renderTree(this.b, e, 0)\n  setDOM(this._root, e)\n}\n\ndocument.addEventListener('DOMContentLoaded', function (e) {\n  benchmark(NAME, VERSION, BenchmarkImpl)\n}, false)\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvc2V0LWRvbS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2V0LWRvbS9zcmMvcGFyc2UtaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy92ZG9tLWJlbmNobWFyay1iYXNlL2xpYi9iZW5jaG1hcmsuanMiLCJub2RlX21vZHVsZXMvdmRvbS1iZW5jaG1hcmstYmFzZS9saWIvZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvdmRvbS1iZW5jaG1hcmstYmFzZS9saWIvaW5kZXguanMiLCJ3ZWIvanMvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0J1xuXG5zZXRET00uS0VZID0gJ2RhdGEta2V5J1xuc2V0RE9NLklHTk9SRSA9ICdkYXRhLWlnbm9yZSdcbnNldERPTS5DSEVDS1NVTSA9ICdkYXRhLWNoZWNrc3VtJ1xudmFyIHBhcnNlSFRNTCA9IHJlcXVpcmUoJy4vcGFyc2UtaHRtbCcpXG52YXIgS0VZX1BSRUZJWCA9ICdfc2V0LWRvbS0nXG52YXIgTk9ERV9NT1VOVEVEID0gS0VZX1BSRUZJWCArICdtb3VudGVkJ1xudmFyIE1PVU5UX0VWRU5UID0gJ21vdW50J1xudmFyIERJU01PVU5UX0VWRU5UID0gJ2Rpc21vdW50J1xudmFyIEVMRU1FTlRfVFlQRSA9IDFcbnZhciBET0NVTUVOVF9UWVBFID0gOVxudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX1RZUEUgPSAxMVxuXG4vLyBFeHBvc2UgYXBpLlxubW9kdWxlLmV4cG9ydHMgPSBzZXRET01cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVwZGF0ZXMgZXhpc3RpbmcgZG9tIHRvIG1hdGNoIGEgbmV3IGRvbS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9sZE5vZGUgLSBUaGUgaHRtbCBlbnRpdHkgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtTdHJpbmd8Tm9kZX0gbmV3Tm9kZSAtIFRoZSB1cGRhdGVkIGh0bWwoZW50aXR5KS5cbiAqL1xuZnVuY3Rpb24gc2V0RE9NIChvbGROb2RlLCBuZXdOb2RlKSB7XG4gIC8vIEVuc3VyZSBhIHJlYWxpc2ggZG9tIG5vZGUgaXMgcHJvdmlkZWQuXG4gIGFzc2VydChvbGROb2RlICYmIG9sZE5vZGUubm9kZVR5cGUsICdZb3UgbXVzdCBwcm92aWRlIGEgdmFsaWQgbm9kZSB0byB1cGRhdGUuJylcblxuICAvLyBBbGlhcyBkb2N1bWVudCBlbGVtZW50IHdpdGggZG9jdW1lbnQuXG4gIGlmIChvbGROb2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFKSBvbGROb2RlID0gb2xkTm9kZS5kb2N1bWVudEVsZW1lbnRcblxuICAvLyBEb2N1bWVudCBGcmFnbWVudHMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLCBzbyBubyBuZWVkIHRvIGxvb2sgYXQgY2hlY2tzdW1zLCBpZ25vcmVkLCBhdHRyaWJ1dGVzLCBvciBub2RlIHJlcGxhY2VtZW50LlxuICBpZiAobmV3Tm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfVFlQRSkge1xuICAgIC8vIFNpbXBseSB1cGRhdGUgYWxsIGNoaWxkcmVuIChhbmQgc3ViY2hpbGRyZW4pLlxuICAgIHNldENoaWxkTm9kZXMob2xkTm9kZSwgbmV3Tm9kZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2Ugd2UgZGlmZiB0aGUgZW50aXJlIG9sZCBub2RlLlxuICAgIHNldE5vZGUob2xkTm9kZSwgdHlwZW9mIG5ld05vZGUgPT09ICdzdHJpbmcnXG4gICAgICAvLyBJZiBhIHN0cmluZyB3YXMgcHJvdmlkZWQgd2Ugd2lsbCBwYXJzZSBpdCBhcyBkb20uXG4gICAgICA/IHBhcnNlSFRNTChuZXdOb2RlLCBvbGROb2RlLm5vZGVOYW1lKVxuICAgICAgOiBuZXdOb2RlXG4gICAgKVxuICB9XG5cbiAgLy8gVHJpZ2dlciBtb3VudCBldmVudHMgb24gaW5pdGlhbCBzZXQuXG4gIGlmICghb2xkTm9kZVtOT0RFX01PVU5URURdKSB7XG4gICAgb2xkTm9kZVtOT0RFX01PVU5URURdID0gdHJ1ZVxuICAgIGRpc3BhdGNoKG9sZE5vZGUsIE1PVU5UX0VWRU5UKVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVXBkYXRlcyBhIHNwZWNpZmljIGh0bWxOb2RlIGFuZCBkb2VzIHdoYXRldmVyIGl0IHRha2VzIHRvIGNvbnZlcnQgaXQgdG8gYW5vdGhlciBvbmUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBvbGROb2RlIC0gVGhlIHByZXZpb3VzIEhUTUxOb2RlLlxuICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlIC0gVGhlIHVwZGF0ZWQgSFRNTE5vZGUuXG4gKi9cbmZ1bmN0aW9uIHNldE5vZGUgKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgaWYgKG9sZE5vZGUubm9kZVR5cGUgPT09IG5ld05vZGUubm9kZVR5cGUpIHtcbiAgICAvLyBIYW5kbGUgcmVndWxhciBlbGVtZW50IG5vZGUgdXBkYXRlcy5cbiAgICBpZiAob2xkTm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9UWVBFKSB7XG4gICAgICAvLyBDaGVja3MgaWYgbm9kZXMgYXJlIGVxdWFsIGJlZm9yZSBkaWZmaW5nLlxuICAgICAgaWYgKGlzRXF1YWxOb2RlKG9sZE5vZGUsIG5ld05vZGUpKSByZXR1cm5cblxuICAgICAgLy8gVXBkYXRlIGFsbCBjaGlsZHJlbiAoYW5kIHN1YmNoaWxkcmVuKS5cbiAgICAgIHNldENoaWxkTm9kZXMob2xkTm9kZSwgbmV3Tm9kZSlcblxuICAgICAgLy8gVXBkYXRlIHRoZSBlbGVtZW50cyBhdHRyaWJ1dGVzIC8gdGFnTmFtZS5cbiAgICAgIGlmIChvbGROb2RlLm5vZGVOYW1lID09PSBuZXdOb2RlLm5vZGVOYW1lKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgdGhlIHNhbWUgbm9kZW5hbWUgdGhlbiB3ZSBjYW4gZGlyZWN0bHkgdXBkYXRlIHRoZSBhdHRyaWJ1dGVzLlxuICAgICAgICBzZXRBdHRyaWJ1dGVzKG9sZE5vZGUuYXR0cmlidXRlcywgbmV3Tm9kZS5hdHRyaWJ1dGVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNsb25lIHRoZSBuZXcgbm9kZSB0byB1c2UgYXMgdGhlIGV4aXN0aW5nIG5vZGUuXG4gICAgICAgIHZhciBuZXdQcmV2ID0gbmV3Tm9kZS5jbG9uZU5vZGUoKVxuICAgICAgICAvLyBDb3B5IG92ZXIgYWxsIGV4aXN0aW5nIGNoaWxkcmVuIGZyb20gdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAgICAgIHdoaWxlIChvbGROb2RlLmZpcnN0Q2hpbGQpIG5ld1ByZXYuYXBwZW5kQ2hpbGQob2xkTm9kZS5maXJzdENoaWxkKVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBvcmlnaW5hbCBub2RlIHdpdGggdGhlIG5ldyBvbmUgd2l0aCB0aGUgcmlnaHQgdGFnLlxuICAgICAgICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1ByZXYsIG9sZE5vZGUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhbmRsZSBvdGhlciB0eXBlcyBvZiBub2RlIHVwZGF0ZXMgKHRleHQvY29tbWVudHMvZXRjKS5cbiAgICAgIC8vIElmIGJvdGggYXJlIHRoZSBzYW1lIHR5cGUgb2Ygbm9kZSB3ZSBjYW4gdXBkYXRlIGRpcmVjdGx5LlxuICAgICAgaWYgKG9sZE5vZGUubm9kZVZhbHVlICE9PSBuZXdOb2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICBvbGROb2RlLm5vZGVWYWx1ZSA9IG5ld05vZGUubm9kZVZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHdlIGhhdmUgdG8gcmVwbGFjZSB0aGUgbm9kZS5cbiAgICBkaXNwYXRjaChvbGROb2RlLCBESVNNT1VOVF9FVkVOVClcbiAgICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpXG4gICAgZGlzcGF0Y2gobmV3Tm9kZSwgTU9VTlRfRVZFTlQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBVdGlsaXR5IHRoYXQgd2lsbCB1cGRhdGUgb25lIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBtYXRjaCBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7TmFtZWROb2RlTWFwfSBvbGRBdHRyaWJ1dGVzIC0gVGhlIHByZXZpb3VzIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge05hbWVkTm9kZU1hcH0gbmV3QXR0cmlidXRlcyAtIFRoZSB1cGRhdGVkIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMgKG9sZEF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpIHtcbiAgdmFyIGksIGEsIGIsIG5zLCBuYW1lXG5cbiAgLy8gUmVtb3ZlIG9sZCBhdHRyaWJ1dGVzLlxuICBmb3IgKGkgPSBvbGRBdHRyaWJ1dGVzLmxlbmd0aDsgaS0tOykge1xuICAgIGEgPSBvbGRBdHRyaWJ1dGVzW2ldXG4gICAgbnMgPSBhLm5hbWVzcGFjZVVSSVxuICAgIG5hbWUgPSBhLmxvY2FsTmFtZVxuICAgIGIgPSBuZXdBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbU5TKG5zLCBuYW1lKVxuICAgIGlmICghYikgb2xkQXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW1OUyhucywgbmFtZSlcbiAgfVxuXG4gIC8vIFNldCBuZXcgYXR0cmlidXRlcy5cbiAgZm9yIChpID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGktLTspIHtcbiAgICBhID0gbmV3QXR0cmlidXRlc1tpXVxuICAgIG5zID0gYS5uYW1lc3BhY2VVUklcbiAgICBuYW1lID0gYS5sb2NhbE5hbWVcbiAgICBiID0gb2xkQXR0cmlidXRlcy5nZXROYW1lZEl0ZW1OUyhucywgbmFtZSlcbiAgICBpZiAoIWIpIHtcbiAgICAgIC8vIEFkZCBhIG5ldyBhdHRyaWJ1dGUuXG4gICAgICBuZXdBdHRyaWJ1dGVzLnJlbW92ZU5hbWVkSXRlbU5TKG5zLCBuYW1lKVxuICAgICAgb2xkQXR0cmlidXRlcy5zZXROYW1lZEl0ZW1OUyhhKVxuICAgIH0gZWxzZSBpZiAoYi52YWx1ZSAhPT0gYS52YWx1ZSkge1xuICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGF0dHJpYnV0ZS5cbiAgICAgIGIudmFsdWUgPSBhLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVXRpbGl0eSB0aGF0IHdpbGwgbm9kZXMgY2hpbGRlcm4gdG8gbWF0Y2ggYW5vdGhlciBub2RlcyBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9sZFBhcmVudCAtIFRoZSBleGlzdGluZyBwYXJlbnQgbm9kZS5cbiAqIEBwYXJhbSB7Tm9kZX0gbmV3UGFyZW50IC0gVGhlIG5ldyBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2hpbGROb2RlcyAob2xkUGFyZW50LCBuZXdQYXJlbnQpIHtcbiAgdmFyIGNoZWNrT2xkLCBvbGRLZXksIGNoZWNrTmV3LCBuZXdLZXksIGZvdW5kTm9kZSwga2V5ZWROb2Rlc1xuICB2YXIgb2xkTm9kZSA9IG9sZFBhcmVudC5maXJzdENoaWxkXG4gIHZhciBuZXdOb2RlID0gbmV3UGFyZW50LmZpcnN0Q2hpbGRcbiAgdmFyIGV4dHJhID0gMFxuXG4gIC8vIEV4dHJhY3Qga2V5ZWQgbm9kZXMgZnJvbSBwcmV2aW91cyBjaGlsZHJlbiBhbmQga2VlcCB0cmFjayBvZiB0b3RhbCBjb3VudC5cbiAgd2hpbGUgKG9sZE5vZGUpIHtcbiAgICBleHRyYSsrXG4gICAgY2hlY2tPbGQgPSBvbGROb2RlXG4gICAgb2xkS2V5ID0gZ2V0S2V5KGNoZWNrT2xkKVxuICAgIG9sZE5vZGUgPSBvbGROb2RlLm5leHRTaWJsaW5nXG5cbiAgICBpZiAob2xkS2V5KSB7XG4gICAgICBpZiAoIWtleWVkTm9kZXMpIGtleWVkTm9kZXMgPSB7fVxuICAgICAga2V5ZWROb2Rlc1tvbGRLZXldID0gY2hlY2tPbGRcbiAgICB9XG4gIH1cblxuICAvLyBMb29wIG92ZXIgbmV3IG5vZGVzIGFuZCBwZXJmb3JtIHVwZGF0ZXMuXG4gIG9sZE5vZGUgPSBvbGRQYXJlbnQuZmlyc3RDaGlsZFxuICB3aGlsZSAobmV3Tm9kZSkge1xuICAgIGV4dHJhLS1cbiAgICBjaGVja05ldyA9IG5ld05vZGVcbiAgICBuZXdOb2RlID0gbmV3Tm9kZS5uZXh0U2libGluZ1xuXG4gICAgaWYgKGtleWVkTm9kZXMgJiYgKG5ld0tleSA9IGdldEtleShjaGVja05ldykpICYmIChmb3VuZE5vZGUgPSBrZXllZE5vZGVzW25ld0tleV0pKSB7XG4gICAgICBkZWxldGUga2V5ZWROb2Rlc1tuZXdLZXldXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEga2V5IGFuZCBpdCBleGlzdGVkIGJlZm9yZSB3ZSBtb3ZlIHRoZSBwcmV2aW91cyBub2RlIHRvIHRoZSBuZXcgcG9zaXRpb24gaWYgbmVlZGVkIGFuZCBkaWZmIGl0LlxuICAgICAgaWYgKGZvdW5kTm9kZSAhPT0gb2xkTm9kZSkge1xuICAgICAgICBvbGRQYXJlbnQuaW5zZXJ0QmVmb3JlKGZvdW5kTm9kZSwgb2xkTm9kZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZE5vZGUgPSBvbGROb2RlLm5leHRTaWJsaW5nXG4gICAgICB9XG5cbiAgICAgIHNldE5vZGUoZm91bmROb2RlLCBjaGVja05ldylcbiAgICB9IGVsc2UgaWYgKG9sZE5vZGUpIHtcbiAgICAgIGNoZWNrT2xkID0gb2xkTm9kZVxuICAgICAgb2xkTm9kZSA9IG9sZE5vZGUubmV4dFNpYmxpbmdcbiAgICAgIGlmIChnZXRLZXkoY2hlY2tPbGQpKSB7XG4gICAgICAgIC8vIElmIHRoZSBvbGQgY2hpbGQgaGFkIGEga2V5IHdlIHNraXAgb3ZlciBpdCB1bnRpbCB0aGUgZW5kLlxuICAgICAgICBvbGRQYXJlbnQuaW5zZXJ0QmVmb3JlKGNoZWNrTmV3LCBjaGVja09sZClcbiAgICAgICAgZGlzcGF0Y2goY2hlY2tOZXcsIE1PVU5UX0VWRU5UKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGRpZmYgdGhlIHR3byBub24ta2V5ZWQgbm9kZXMuXG4gICAgICAgIHNldE5vZGUoY2hlY2tPbGQsIGNoZWNrTmV3KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5hbGx5IGlmIHRoZXJlIHdhcyBubyBvbGQgbm9kZSB3ZSBhZGQgdGhlIG5ldyBub2RlLlxuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKGNoZWNrTmV3KVxuICAgICAgZGlzcGF0Y2goY2hlY2tOZXcsIE1PVU5UX0VWRU5UKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBvbGQga2V5ZWQgbm9kZXMuXG4gIGZvciAob2xkS2V5IGluIGtleWVkTm9kZXMpIHtcbiAgICBleHRyYS0tXG4gICAgb2xkUGFyZW50LnJlbW92ZUNoaWxkKGtleWVkTm9kZXNbb2xkS2V5XSlcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyB1bmtleWVkIG5vZGVzIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVuZC5cbiAgd2hpbGUgKC0tZXh0cmEgPj0gMCkge1xuICAgIG9sZFBhcmVudC5yZW1vdmVDaGlsZChkaXNwYXRjaChvbGRQYXJlbnQubGFzdENoaWxkLCBESVNNT1VOVF9FVkVOVCkpXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBVdGlsaXR5IHRvIHRyeSB0byBwdWxsIGEga2V5IG91dCBvZiBhbiBlbGVtZW50LlxuICogVXNlcyAnZGF0YS1rZXknIGlmIHBvc3NpYmxlIGFuZCBmYWxscyBiYWNrIHRvICdpZCcuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBrZXkgZm9yLlxuICogQHJldHVybiB7c3RyaW5nfHZvaWR9XG4gKi9cbmZ1bmN0aW9uIGdldEtleSAobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9UWVBFKSByZXR1cm5cbiAgdmFyIGtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKHNldERPTS5LRVkpIHx8IG5vZGUuaWRcbiAgaWYgKGtleSkgcmV0dXJuIEtFWV9QUkVGSVggKyBrZXlcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgbm9kZXMgYXJlIGVxdWFsIHVzaW5nIHRoZSBmb2xsb3dpbmcgYnkgY2hlY2tpbmcgaWZcbiAqIHRoZXkgYXJlIGJvdGggaWdub3JlZCwgaGF2ZSB0aGUgc2FtZSBjaGVja3N1bSwgb3IgaGF2ZSB0aGVcbiAqIHNhbWUgY29udGVudHMuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBhIC0gT25lIG9mIHRoZSBub2RlcyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtOb2RlfSBiIC0gQW5vdGhlciBub2RlIHRvIGNvbXBhcmUuXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWxOb2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQ2hlY2sgaWYgYm90aCBub2RlcyBhcmUgaWdub3JlZC5cbiAgICAoaXNJZ25vcmVkKGEpICYmIGlzSWdub3JlZChiKSkgfHxcbiAgICAvLyBDaGVjayBpZiBib3RoIG5vZGVzIGhhdmUgdGhlIHNhbWUgY2hlY2tzdW0uXG4gICAgKGdldENoZWNrU3VtKGEpID09PSBnZXRDaGVja1N1bShiKSkgfHxcbiAgICAvLyBGYWxsIGJhY2sgdG8gbmF0aXZlIGlzRXF1YWxOb2RlIGNoZWNrLlxuICAgIGEuaXNFcXVhbE5vZGUoYilcbiAgKVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFV0aWxpdHkgdG8gdHJ5IHRvIHB1bGwgYSBjaGVja3N1bSBhdHRyaWJ1dGUgZnJvbSBhbiBlbGVtZW50LlxuICogVXNlcyAnZGF0YS1jaGVja3N1bScgb3IgdXNlciBzcGVjaWZpZWQgY2hlY2tzdW0gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBjaGVja3N1bSBmb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd8TmFOfVxuICovXG5mdW5jdGlvbiBnZXRDaGVja1N1bSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoc2V0RE9NLkNIRUNLU1VNKSB8fCBOYU5cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBVdGlsaXR5IHRvIHRyeSB0byBjaGVjayBpZiBhbiBlbGVtZW50IHNob3VsZCBiZSBpZ25vcmVkIGJ5IHRoZSBhbGdvcml0aG0uXG4gKiBVc2VzICdkYXRhLWlnbm9yZScgb3IgdXNlciBzcGVjaWZpZWQgaWdub3JlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIGNoZWNrIGlmIGl0IHNob3VsZCBiZSBpZ25vcmVkLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNJZ25vcmVkIChub2RlKSB7XG4gIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShzZXRET00uSUdOT1JFKSAhPSBudWxsXG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJpZ2dlciBhbiBldmVudCBmb3IgYSBub2RlIGFuZCBpdCdzIGNoaWxkcmVuLlxuICogT25seSBlbWl0cyBldmVudHMgZm9yIGtleWVkIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIHRoZSBpbml0aWFsIG5vZGUuXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaCAobm9kZSwgdHlwZSkge1xuICAvLyBUcmlnZ2VyIGV2ZW50IGZvciB0aGlzIGVsZW1lbnQgaWYgaXQgaGFzIGEga2V5LlxuICBpZiAoZ2V0S2V5KG5vZGUpKSB7XG4gICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgICB2YXIgcHJvcCA9IHsgdmFsdWU6IG5vZGUgfVxuICAgIGV2LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2LCAndGFyZ2V0JywgcHJvcClcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXYsICdzcmNFbGVtZW50JywgcHJvcClcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXYpXG4gIH1cblxuICAvLyBEaXNwYXRjaCB0byBhbGwgY2hpbGRyZW4uXG4gIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZFxuICB3aGlsZSAoY2hpbGQpIGNoaWxkID0gZGlzcGF0Y2goY2hpbGQsIHR5cGUpLm5leHRTaWJsaW5nXG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogQ29uZmlybSB0aGF0IGEgdmFsdWUgaXMgdHJ1dGh5LCB0aHJvd3MgYW4gZXJyb3IgbWVzc2FnZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgLSB0aGUgdmFsIHRvIHRlc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnIC0gdGhlIGVycm9yIG1lc3NhZ2Ugb24gZmFpbHVyZS5cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5mdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IoJ3NldC1kb206ICcgKyBtc2cpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHBhcnNlciA9IHdpbmRvdy5ET01QYXJzZXIgJiYgbmV3IHdpbmRvdy5ET01QYXJzZXIoKVxudmFyIGRvY3VtZW50Um9vdE5hbWUgPSAnSFRNTCdcbnZhciBzdXBwb3J0c0hUTUxUeXBlID0gZmFsc2VcbnZhciBzdXBwb3J0c0lubmVySFRNTCA9IGZhbHNlXG52YXIgaHRtbFR5cGUgPSAndGV4dC9odG1sJ1xudmFyIHhodG1sVHlwZSA9ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnXG52YXIgdGVzdENvZGUgPSAnPGJyLz4nXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBGYWlscyBpbiBvbGRlciBicm93c2VycyAqL1xudHJ5IHtcbiAgLy8gQ2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0cyB0ZXh0L2h0bWwgRE9NUGFyc2VyXG4gIGlmIChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRlc3RDb2RlLCBodG1sVHlwZSkpIHN1cHBvcnRzSFRNTFR5cGUgPSB0cnVlXG59IGNhdGNoIChlKSB7XG4gIHZhciBtb2NrRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKVxuICB2YXIgbW9ja0hUTUwgPSBtb2NrRG9jLmRvY3VtZW50RWxlbWVudFxuICB2YXIgbW9ja0JvZHkgPSBtb2NrRG9jLmJvZHlcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiBicm93c2VyIHN1cHBvcnRzIGRvY3VtZW50RWxlbWVudC5pbm5lckhUTUxcbiAgICBtb2NrSFRNTC5pbm5lckhUTUwgKz0gJydcbiAgICBzdXBwb3J0c0lubmVySFRNTCA9IHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydHMgeGh0bWwgcGFyc2luZy5cbiAgICBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRlc3RDb2RlLCB4aHRtbFR5cGUpXG4gICAgdmFyIGJvZHlSZWcgPSAvKDxib2R5W14+XSo+KShbXFxzXFxTXSopPFxcL2JvZHk+L1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhIERPTVBhcnNlciBhcyBhbiBIVE1MRWxlbWVudC5cbiAqIChTaGltcyBmb3Igb2xkZXIgYnJvd3NlcnMpLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzSFRNTFR5cGVcbiAgPyBmdW5jdGlvbiBwYXJzZUhUTUwgKG1hcmt1cCwgcm9vdE5hbWUpIHtcbiAgICB2YXIgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhtYXJrdXAsIGh0bWxUeXBlKVxuICAgIHJldHVybiByb290TmFtZSA9PT0gZG9jdW1lbnRSb290TmFtZVxuICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50XG4gICAgICA6IGRvYy5ib2R5LmZpcnN0Q2hpbGRcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogT25seSB1c2VkIGluIG9sZGVyIGJyb3dzZXJzICovXG4gIDogZnVuY3Rpb24gcGFyc2VIVE1MIChtYXJrdXAsIHJvb3ROYW1lKSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gaW5uZXJIVE1MIGZvciBvdGhlciBvbGRlciBicm93c2Vycy5cbiAgICBpZiAocm9vdE5hbWUgPT09IGRvY3VtZW50Um9vdE5hbWUpIHtcbiAgICAgIGlmIChzdXBwb3J0c0lubmVySFRNTCkge1xuICAgICAgICBtb2NrSFRNTC5pbm5lckhUTUwgPSBtYXJrdXBcbiAgICAgICAgcmV0dXJuIG1vY2tIVE1MXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJRTkgZG9lcyBub3Qgc3VwcG9ydCBpbm5lcmh0bWwgYXQgcm9vdCBsZXZlbC5cbiAgICAgICAgLy8gV2UgZ2V0IGFyb3VuZCB0aGlzIGJ5IHBhcnNpbmcgZXZlcnl0aGluZyBleGNlcHQgdGhlIGJvZHkgYXMgeGh0bWwuXG4gICAgICAgIHZhciBib2R5TWF0Y2ggPSBtYXJrdXAubWF0Y2goYm9keVJlZylcbiAgICAgICAgaWYgKGJvZHlNYXRjaCkge1xuICAgICAgICAgIHZhciBib2R5Q29udGVudCA9IGJvZHlNYXRjaFsyXVxuICAgICAgICAgIHZhciBzdGFydEJvZHkgPSBib2R5TWF0Y2guaW5kZXggKyBib2R5TWF0Y2hbMV0ubGVuZ3RoXG4gICAgICAgICAgdmFyIGVuZEJvZHkgPSBzdGFydEJvZHkgKyBib2R5Q29udGVudC5sZW5ndGhcbiAgICAgICAgICBtYXJrdXAgPSBtYXJrdXAuc2xpY2UoMCwgc3RhcnRCb2R5KSArIG1hcmt1cC5zbGljZShlbmRCb2R5KVxuICAgICAgICAgIG1vY2tCb2R5LmlubmVySFRNTCA9IGJvZHlDb250ZW50XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhtYXJrdXAsIHhodG1sVHlwZSlcbiAgICAgICAgdmFyIGJvZHkgPSBkb2MuYm9keVxuICAgICAgICB3aGlsZSAobW9ja0JvZHkuZmlyc3RDaGlsZCkgYm9keS5hcHBlbmRDaGlsZChtb2NrQm9keS5maXJzdENoaWxkKVxuICAgICAgICByZXR1cm4gZG9jLmRvY3VtZW50RWxlbWVudFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2NrQm9keS5pbm5lckhUTUwgPSBtYXJrdXBcbiAgICAgIHJldHVybiBtb2NrQm9keS5maXJzdENoaWxkXG4gICAgfVxuICB9XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRvciA9IHJlcXVpcmUoJy4vZXhlY3V0b3InKTtcblxuZnVuY3Rpb24gQmVuY2htYXJrKCkge1xuICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgdGhpcy5pbXBsID0gbnVsbDtcbiAgdGhpcy50ZXN0cyA9IG51bGw7XG4gIHRoaXMucmVwb3J0Q2FsbGJhY2sgPSBudWxsO1xuICB0aGlzLmVuYWJsZVRlc3RzID0gZmFsc2U7XG5cbiAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICB0aGlzLl9ydW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnUnVuQnV0dG9uJyk7XG4gIHRoaXMuX2l0ZXJhdGlvbnNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ0l0ZXJhdGlvbnMnKTtcbiAgdGhpcy5fcmVwb3J0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3JlcG9ydEVsZW1lbnQpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9ydW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKCFzZWxmLnJ1bm5pbmcpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gcGFyc2VJbnQoc2VsZi5faXRlcmF0aW9uc0VsZW1lbnQudmFsdWUpO1xuICAgICAgaWYgKGl0ZXJhdGlvbnMgPD0gMCkge1xuICAgICAgICBpdGVyYXRpb25zID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucnVuKGl0ZXJhdGlvbnMpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHRoaXMucmVhZHkodHJ1ZSk7XG59XG5cbkJlbmNobWFyay5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbih2KSB7XG4gIGlmICh2KSB7XG4gICAgdGhpcy5fcnVuQnV0dG9uLmRpc2FibGVkID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcnVuQnV0dG9uLmRpc2FibGVkID0gJ3RydWUnO1xuICB9XG59O1xuXG5CZW5jaG1hcmsucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGl0ZXJhdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICB0aGlzLnJlYWR5KGZhbHNlKTtcblxuICBuZXcgRXhlY3V0b3Ioc2VsZi5pbXBsLCBzZWxmLmNvbnRhaW5lciwgc2VsZi50ZXN0cywgMSwgZnVuY3Rpb24oKSB7IC8vIHdhcm11cFxuICAgIG5ldyBFeGVjdXRvcihzZWxmLmltcGwsIHNlbGYuY29udGFpbmVyLCBzZWxmLnRlc3RzLCBpdGVyYXRpb25zLCBmdW5jdGlvbihzYW1wbGVzKSB7XG4gICAgICBzZWxmLl9yZXBvcnRFbGVtZW50LnRleHRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoc2FtcGxlcywgbnVsbCwgJyAnKTtcbiAgICAgIHNlbGYucnVubmluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5yZWFkeSh0cnVlKTtcbiAgICAgIGlmIChzZWxmLnJlcG9ydENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2VsZi5yZXBvcnRDYWxsYmFjayhzYW1wbGVzKTtcbiAgICAgIH1cbiAgICB9LCB1bmRlZmluZWQsIGZhbHNlKS5zdGFydCgpO1xuICB9LCB1bmRlZmluZWQsIHRoaXMuZW5hYmxlVGVzdHMpLnN0YXJ0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlbmNobWFyaztcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcmVuZGVyKG5vZGVzKSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgajtcbiAgdmFyIGM7XG4gIHZhciBpO1xuICB2YXIgZTtcbiAgdmFyIG47XG5cbiAgZm9yIChpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbiA9IG5vZGVzW2ldO1xuICAgIGlmIChuLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjID0gcmVuZGVyKG4uY2hpbGRyZW4pO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZS5hcHBlbmRDaGlsZChjW2pdKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnB1c2goZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBlLnRleHRDb250ZW50ID0gbi5rZXkudG9TdHJpbmcoKTtcbiAgICAgIGNoaWxkcmVuLnB1c2goZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiB0ZXN0SW5uZXJIdG1sKHRlc3ROYW1lLCBub2RlcywgY29udGFpbmVyKSB7XG4gIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBjaGlsZHJlbiA9IHJlbmRlcihub2Rlcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBlLmFwcGVuZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgfVxuICBjLmFwcGVuZENoaWxkKGUpO1xuICBpZiAoYy5pbm5lckhUTUwgIT09IGNvbnRhaW5lci5pbm5lckhUTUwpIHtcbiAgICBjb25zb2xlLmxvZygnZXJyb3IgaW4gdGVzdDogJyArIHRlc3ROYW1lKTtcbiAgICBjb25zb2xlLmxvZygnY29udGFpbmVyLmlubmVySFRNTDonKTtcbiAgICBjb25zb2xlLmxvZyhjb250YWluZXIuaW5uZXJIVE1MKTtcbiAgICBjb25zb2xlLmxvZygnc2hvdWxkIGJlOicpO1xuICAgIGNvbnNvbGUubG9nKGMuaW5uZXJIVE1MKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIEV4ZWN1dG9yKGltcGwsIGNvbnRhaW5lciwgdGVzdHMsIGl0ZXJhdGlvbnMsIGNiLCBpdGVyQ2IsIGVuYWJsZVRlc3RzKSB7XG4gIGlmIChpdGVyQ2IgPT09IHZvaWQgMCkgaXRlckNiID0gbnVsbDtcblxuICB0aGlzLmltcGwgPSBpbXBsO1xuICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgdGhpcy50ZXN0cyA9IHRlc3RzO1xuICB0aGlzLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaXRlckNiID0gaXRlckNiO1xuICB0aGlzLmVuYWJsZVRlc3RzID0gZW5hYmxlVGVzdHM7XG5cbiAgdGhpcy5fY3VycmVudFRlc3QgPSAwO1xuICB0aGlzLl9jdXJyZW50SXRlciA9IDA7XG4gIHRoaXMuX3JlbmRlclNhbXBsZXMgPSBbXTtcbiAgdGhpcy5fdXBkYXRlU2FtcGxlcyA9IFtdO1xuICB0aGlzLl9yZXN1bHQgPSBbXTtcblxuICB0aGlzLl90YXNrc0NvdW50ID0gdGVzdHMubGVuZ3RoICogaXRlcmF0aW9ucztcblxuICB0aGlzLl9pdGVyID0gdGhpcy5pdGVyLmJpbmQodGhpcyk7XG59XG5cbkV4ZWN1dG9yLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9pdGVyKCk7XG59O1xuXG5FeGVjdXRvci5wcm90b3R5cGUuZmluaXNoZWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYih0aGlzLl9yZXN1bHQpO1xufTtcblxuRXhlY3V0b3IucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9jdXJyZW50VGVzdCA9PT0gMCAmJiB0aGlzLl9jdXJyZW50SXRlciA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHRlc3RzID0gdGhpcy50ZXN0cztcbiAgcmV0dXJuICh0aGlzLl9jdXJyZW50VGVzdCAqIHRlc3RzLmxlbmd0aCArIHRoaXMuX2N1cnJlbnRJdGVyKSAvICh0ZXN0cy5sZW5ndGggKiB0aGlzLml0ZXJhdGFpb25zKTtcbn07XG5cbkV4ZWN1dG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLml0ZXJDYiAhPSBudWxsKSB7XG4gICAgdGhpcy5pdGVyQ2IodGhpcyk7XG4gIH1cblxuICB2YXIgdGVzdHMgPSB0aGlzLnRlc3RzO1xuXG4gIGlmICh0aGlzLl9jdXJyZW50VGVzdCA8IHRlc3RzLmxlbmd0aCkge1xuICAgIHZhciB0ZXN0ID0gdGVzdHNbdGhpcy5fY3VycmVudFRlc3RdO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRJdGVyIDwgdGhpcy5pdGVyYXRpb25zKSB7XG4gICAgICB2YXIgZSwgdDtcbiAgICAgIHZhciByZW5kZXJUaW1lLCB1cGRhdGVUaW1lO1xuXG4gICAgICBlID0gbmV3IHRoaXMuaW1wbCh0aGlzLmNvbnRhaW5lciwgdGVzdC5kYXRhLmEsIHRlc3QuZGF0YS5iKTtcbiAgICAgIGUuc2V0VXAoKTtcblxuICAgICAgdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGUucmVuZGVyKCk7XG4gICAgICByZW5kZXJUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gdDtcblxuICAgICAgaWYgKHRoaXMuZW5hYmxlVGVzdHMpIHtcbiAgICAgICAgdGVzdElubmVySHRtbCh0ZXN0Lm5hbWUgKyAncmVuZGVyKCknLCB0ZXN0LmRhdGEuYSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICB0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgZS51cGRhdGUoKTtcbiAgICAgIHVwZGF0ZVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuXG4gICAgICBpZiAodGhpcy5lbmFibGVUZXN0cykge1xuICAgICAgICB0ZXN0SW5uZXJIdG1sKHRlc3QubmFtZSArICd1cGRhdGUoKScsIHRlc3QuZGF0YS5iLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGUudGVhckRvd24oKTtcblxuICAgICAgdGhpcy5fcmVuZGVyU2FtcGxlcy5wdXNoKHJlbmRlclRpbWUpO1xuICAgICAgdGhpcy5fdXBkYXRlU2FtcGxlcy5wdXNoKHVwZGF0ZVRpbWUpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50SXRlcisrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN1bHQucHVzaCh7XG4gICAgICAgIG5hbWU6IHRlc3QubmFtZSArICcgJyArICdyZW5kZXIoKScsXG4gICAgICAgIGRhdGE6IHRoaXMuX3JlbmRlclNhbXBsZXMuc2xpY2UoMClcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXN1bHQucHVzaCh7XG4gICAgICAgIG5hbWU6IHRlc3QubmFtZSArICcgJyArICd1cGRhdGUoKScsXG4gICAgICAgIGRhdGE6IHRoaXMuX3VwZGF0ZVNhbXBsZXMuc2xpY2UoMClcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9jdXJyZW50VGVzdCsrO1xuXG4gICAgICB0aGlzLl9jdXJyZW50SXRlciA9IDA7XG4gICAgICB0aGlzLl9yZW5kZXJTYW1wbGVzID0gW107XG4gICAgICB0aGlzLl91cGRhdGVTYW1wbGVzID0gW107XG4gICAgfVxuXG4gICAgc2V0VGltZW91dCh0aGlzLl9pdGVyLCAwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmlzaGVkKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCZW5jaG1hcmsgPSByZXF1aXJlKCcuL2JlbmNobWFyaycpO1xudmFyIGJlbmNobWFyayA9IG5ldyBCZW5jaG1hcmsoKTtcblxuZnVuY3Rpb24gaW5pdEZyb21TY3JpcHQoc2NyaXB0VXJsLCBpbXBsKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIGUuc3JjID0gc2NyaXB0VXJsO1xuXG4gIGUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgYmVuY2htYXJrLnRlc3RzID0gd2luZG93LmdlbmVyYXRlQmVuY2htYXJrRGF0YSgpLnVuaXRzO1xuICAgIGJlbmNobWFyay5yZWFkeSh0cnVlKTtcbiAgfTtcblxuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpO1xufVxuXG5mdW5jdGlvbiBpbml0RnJvbVBhcmVudFdpbmRvdyhwYXJlbnQsIG5hbWUsIHZlcnNpb24sIGlkKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICd0ZXN0cycpIHtcbiAgICAgIGJlbmNobWFyay50ZXN0cyA9IGRhdGEuZGF0YTtcbiAgICAgIGJlbmNobWFyay5yZXBvcnRDYWxsYmFjayA9IGZ1bmN0aW9uKHNhbXBsZXMpIHtcbiAgICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiAncmVwb3J0JyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgIHNhbXBsZXM6IHNhbXBsZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9LCAnKicpO1xuICAgICAgfTtcbiAgICAgIGJlbmNobWFyay5yZWFkeSh0cnVlKTtcblxuICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3JlYWR5JyxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgaWQ6IGlkXG4gICAgICB9LCAnKicpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3J1bicpIHtcbiAgICAgIGJlbmNobWFyay5ydW4oZGF0YS5kYXRhLml0ZXJhdGlvbnMpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHBhcmVudC5wb3N0TWVzc2FnZSh7XG4gICAgdHlwZTogJ2luaXQnLFxuICAgIGRhdGE6IG51bGwsXG4gICAgaWQ6IGlkXG4gIH0sICcqJyk7XG59XG5cbmZ1bmN0aW9uIGluaXQobmFtZSwgdmVyc2lvbiwgaW1wbCkge1xuICAvLyBQYXJzZSBRdWVyeSBTdHJpbmcuXG4gIHZhciBxcyA9IChmdW5jdGlvbihhKSB7XG4gICAgaWYgKGEgPT0gXCJcIikgcmV0dXJuIHt9O1xuICAgIHZhciBiID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcD1hW2ldLnNwbGl0KCc9JywgMik7XG4gICAgICBpZiAocC5sZW5ndGggPT0gMSkge1xuICAgICAgICBiW3BbMF1dID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJbcFswXV0gPSBkZWNvZGVVUklDb21wb25lbnQocFsxXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGI7XG4gIH0pKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpLnNwbGl0KCcmJykpO1xuXG4gIGlmIChxc1snbmFtZSddICE9PSB2b2lkIDApIHtcbiAgICBuYW1lID0gcXNbJ25hbWUnXTtcbiAgfVxuXG4gIGlmIChxc1sndmVyc2lvbiddICE9PSB2b2lkIDApIHtcbiAgICB2ZXJzaW9uID0gcXNbJ3ZlcnNpb24nXTtcbiAgfVxuXG4gIHZhciB0eXBlID0gcXNbJ3R5cGUnXTtcblxuICBpZiAocXNbJ3Rlc3QnXSAhPT0gdm9pZCAwKSB7XG4gICAgYmVuY2htYXJrLmVuYWJsZVRlc3RzID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZygndGVzdHMgZW5hYmxlZCcpO1xuICB9XG5cbiAgdmFyIGlkO1xuICBpZiAodHlwZSA9PT0gJ2lmcmFtZScpIHtcbiAgICBpZCA9IHFzWydpZCddO1xuICAgIGlmIChpZCA9PT0gdm9pZCAwKSBpZCA9IG51bGw7XG4gICAgaW5pdEZyb21QYXJlbnRXaW5kb3cod2luZG93LnBhcmVudCwgbmFtZSwgdmVyc2lvbiwgaWQpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd3aW5kb3cnKSB7XG4gICAgaWYgKHdpbmRvdy5vcGVuZXIgIT0gbnVsbCkge1xuICAgICAgaWQgPSBxc1snaWQnXTtcbiAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSBpZCA9IG51bGw7XG4gICAgICBpbml0RnJvbVBhcmVudFdpbmRvdyh3aW5kb3cub3BlbmVyLCBuYW1lLCB2ZXJzaW9uLCBpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZTogb3BlbmVyIHdpbmRvdyBpcyBOVUxMJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0ZXN0c1VybCA9IHFzWydkYXRhJ107IC8vIHVybCB0byB0aGUgc2NyaXB0IGdlbmVyYXRpbmcgdGVzdCBkYXRhXG4gICAgaWYgKHRlc3RzVXJsICE9PSB2b2lkIDApIHtcbiAgICAgIGluaXRGcm9tU2NyaXB0KHRlc3RzVXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBpbml0aWFsaXplOiBjYW5ub3QgbG9hZCB0ZXN0cyBkYXRhJyk7XG4gICAgfVxuICB9XG5cbiAgYmVuY2htYXJrLmltcGwgPSBpbXBsO1xufVxuXG4vLyBwZXJmb3JtYW5jZS5ub3coKSBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzU0Mzg2NTBcbi8vIHByZXBhcmUgYmFzZSBwZXJmIG9iamVjdFxuaWYgKHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHt9O1xufVxuaWYgKCF3aW5kb3cucGVyZm9ybWFuY2Uubm93KXtcbiAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG4gIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCkge1xuICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gIH1cbiAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uIG5vdygpe1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQ7XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJlbmNobWFyayA9IHJlcXVpcmUoJ3Zkb20tYmVuY2htYXJrLWJhc2UnKVxudmFyIHNldERPTSA9IHJlcXVpcmUoJ3NldC1kb20nKVxuXG52YXIgTkFNRSA9ICdzZXQtZG9tJ1xudmFyIFZFUlNJT04gPSAnOC4wLjAnXG5cbmZ1bmN0aW9uIHJlbmRlclRyZWUgKG5vZGVzLCBwYXJlbnQsIGRlcHRoKSB7XG4gIHZhciBlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldXG4gICAgaWYgKG4uY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZS5pZCA9ICcnICsgZGVwdGggKyAnXycgKyBuLmtleVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGUpXG4gICAgICByZW5kZXJUcmVlKG4uY2hpbGRyZW4sIGUsIGRlcHRoICsgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgZS5pZCA9ICcnICsgZGVwdGggKyAnXycgKyBuLmtleVxuICAgICAgZS50ZXh0Q29udGVudCA9IG4ua2V5XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmVuY2htYXJrSW1wbCAoY29udGFpbmVyLCBhLCBiKSB7XG4gIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyXG4gIHRoaXMuYSA9IGFcbiAgdGhpcy5iID0gYlxuICB0aGlzLl9yb290ID0gbnVsbFxufVxuXG5CZW5jaG1hcmtJbXBsLnByb3RvdHlwZS5zZXRVcCA9IGZ1bmN0aW9uICgpIHt9XG5cbkJlbmNobWFya0ltcGwucHJvdG90eXBlLnRlYXJEb3duID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lci5maXJzdENoaWxkKVxufVxuXG5CZW5jaG1hcmtJbXBsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICByZW5kZXJUcmVlKHRoaXMuYSwgdGhpcy5fcm9vdCwgMClcbiAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdClcbn1cblxuQmVuY2htYXJrSW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHJlbmRlclRyZWUodGhpcy5iLCBlLCAwKVxuICBzZXRET00odGhpcy5fcm9vdCwgZSlcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIChlKSB7XG4gIGJlbmNobWFyayhOQU1FLCBWRVJTSU9OLCBCZW5jaG1hcmtJbXBsKVxufSwgZmFsc2UpXG4iXX0="}