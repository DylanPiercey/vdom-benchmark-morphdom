{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/set-dom/src/index.js","node_modules/set-dom/src/parse-html.js","node_modules/vdom-benchmark-base/lib/benchmark.js","node_modules/vdom-benchmark-base/lib/executor.js","node_modules/vdom-benchmark-base/lib/index.js","package.json","web/js/main.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict'\n\nsetDOM.KEY = 'data-key'\nsetDOM.IGNORE = 'data-ignore'\nsetDOM.CHECKSUM = 'data-checksum'\nvar parseHTML = require('./parse-html')\nvar KEY_PREFIX = '_set-dom-'\nvar NODE_MOUNTED = KEY_PREFIX + 'mounted'\nvar MOUNT_EVENT = 'mount'\nvar DISMOUNT_EVENT = 'dismount'\nvar ELEMENT_TYPE = window.Node.ELEMENT_NODE\nvar DOCUMENT_TYPE = window.Node.DOCUMENT_NODE\n\n// Expose api.\nmodule.exports = setDOM\n\n/**\n * @description\n * Updates existing dom to match a new dom.\n *\n * @param {Node} oldNode - The html entity to update.\n * @param {String|Node} newNode - The updated html(entity).\n */\nfunction setDOM (oldNode, newNode) {\n  // Ensure a realish dom node is provided.\n  assert(oldNode && oldNode.nodeType, 'You must provide a valid node to update.')\n\n  // Alias document element with document.\n  if (oldNode.nodeType === DOCUMENT_TYPE) oldNode = oldNode.documentElement\n\n  // If a string was provided we will parse it as dom.\n  if (typeof newNode === 'string') newNode = parseHTML(newNode, oldNode.nodeName)\n\n  // Update the node.\n  setNode(oldNode, newNode)\n\n  // Trigger mount events on initial set.\n  if (!oldNode[NODE_MOUNTED]) {\n    oldNode[NODE_MOUNTED] = true\n    dispatch(oldNode, MOUNT_EVENT)\n  }\n}\n\n/**\n * @private\n * @description\n * Updates a specific htmlNode and does whatever it takes to convert it to another one.\n *\n * @param {Node} oldNode - The previous HTMLNode.\n * @param {Node} newNode - The updated HTMLNode.\n */\nfunction setNode (oldNode, newNode) {\n  if (oldNode.nodeType === newNode.nodeType) {\n    // Handle regular element node updates.\n    if (oldNode.nodeType === ELEMENT_TYPE) {\n      // Ignore elements if their checksum matches.\n      if (getCheckSum(oldNode) === getCheckSum(newNode)) return\n      // Ignore elements that explicity choose not to be diffed.\n      if (isIgnored(oldNode) && isIgnored(newNode)) return\n\n      // Update all children (and subchildren).\n      setChildNodes(oldNode, newNode)\n\n      // Update the elements attributes / tagName.\n      if (oldNode.nodeName === newNode.nodeName) {\n        // If we have the same nodename then we can directly update the attributes.\n        setAttributes(oldNode.attributes, newNode.attributes)\n      } else {\n        // Otherwise clone the new node to use as the existing node.\n        var newPrev = newNode.cloneNode()\n        // Copy over all existing children from the original node.\n        while (oldNode.firstChild) newPrev.appendChild(oldNode.firstChild)\n        // Replace the original node with the new one with the right tag.\n        oldNode.parentNode.replaceChild(newPrev, oldNode)\n      }\n    } else {\n      // Handle other types of node updates (text/comments/etc).\n      // If both are the same type of node we can update directly.\n      if (oldNode.nodeValue !== newNode.nodeValue) {\n        oldNode.nodeValue = newNode.nodeValue\n      }\n    }\n  } else {\n    // we have to replace the node.\n    dispatch(oldNode, DISMOUNT_EVENT)\n    oldNode.parentNode.replaceChild(newNode, oldNode)\n    dispatch(newNode, MOUNT_EVENT)\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will update one list of attributes to match another.\n *\n * @param {NamedNodeMap} oldAttributes - The previous attributes.\n * @param {NamedNodeMap} newAttributes - The updated attributes.\n */\nfunction setAttributes (oldAttributes, newAttributes) {\n  var i, a, b, ns, name\n\n  // Remove old attributes.\n  for (i = oldAttributes.length; i--;) {\n    a = oldAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = newAttributes.getNamedItemNS(ns, name)\n    if (!b) oldAttributes.removeNamedItemNS(ns, name)\n  }\n\n  // Set new attributes.\n  for (i = newAttributes.length; i--;) {\n    a = newAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = oldAttributes.getNamedItemNS(ns, name)\n    if (!b) {\n      // Add a new attribute.\n      newAttributes.removeNamedItemNS(ns, name)\n      oldAttributes.setNamedItemNS(a)\n    } else if (b.value !== a.value) {\n      // Update existing attribute.\n      b.value = a.value\n    }\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will nodes childern to match another nodes children.\n *\n * @param {Node} oldParent - The existing parent node.\n * @param {Node} newParent - The new parent node.\n */\nfunction setChildNodes (oldParent, newParent) {\n  var checkOld, oldKey, checkNew, newKey, foundNode, keyedNodes\n  var oldNode = oldParent.firstChild\n  var newNode = newParent.firstChild\n  var extra = 0\n\n  // Extract keyed nodes from previous children and keep track of total count.\n  while (oldNode) {\n    extra++\n    checkOld = oldNode\n    oldKey = getKey(checkOld)\n    oldNode = oldNode.nextSibling\n\n    if (oldKey) {\n      if (!keyedNodes) keyedNodes = {}\n      keyedNodes[oldKey] = checkOld\n    }\n  }\n\n  // Loop over new nodes and perform updates.\n  oldNode = oldParent.firstChild\n  while (newNode) {\n    extra--\n    checkNew = newNode\n    newNode = newNode.nextSibling\n\n    if (keyedNodes && (newKey = getKey(checkNew)) && (foundNode = keyedNodes[newKey])) {\n      // If we have a key and it existed before we move the previous node to the new position and diff it.\n      oldParent.insertBefore(foundNode, oldNode)\n      setNode(foundNode, checkNew)\n    } else if (oldNode && !getKey(oldNode)) {\n      // If there was no keys on either side we simply diff the nodes.\n      checkOld = oldNode\n      oldNode = oldNode.nextSibling\n      setNode(checkOld, checkNew)\n    } else {\n      // Otherwise we append or insert the new node at the proper position.\n      oldParent.insertBefore(checkNew, oldNode)\n      dispatch(checkNew, MOUNT_EVENT)\n    }\n  }\n\n  // If we have any remaining remove them from the end.\n  while (--extra >= 0) {\n    oldParent.removeChild(dispatch(oldParent.lastChild, DISMOUNT_EVENT))\n  }\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a key out of an element.\n * Uses 'data-key' if possible and falls back to 'id'.\n *\n * @param {Node} node - The node to get the key for.\n * @return {string|void}\n */\nfunction getKey (node) {\n  if (node.nodeType !== ELEMENT_TYPE) return\n  var key = node.getAttribute(setDOM.KEY) || node.id\n  if (key) return KEY_PREFIX + key\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a checksum attribute from an element.\n * Uses 'data-checksum' or user specified checksum property.\n *\n * @param {Node} node - The node to get the checksum for.\n * @return {string|NaN}\n */\nfunction getCheckSum (node) {\n  return node.getAttribute(setDOM.CHECKSUM) || NaN\n}\n\n/**\n * @private\n * @description\n * Utility to try to check if an element should be ignored by the algorithm.\n * Uses 'data-ignore' or user specified ignore property.\n *\n * @param {Node} node - The node to check if it should be ignored.\n * @return {boolean}\n */\nfunction isIgnored (node) {\n  return node.getAttribute(setDOM.IGNORE) != null\n}\n\n/**\n * Recursively trigger an event for a node and it's children.\n * Only emits events for keyed nodes.\n *\n * @param {Node} node - the initial node.\n * @return {Node}\n */\nfunction dispatch (node, type) {\n  // Trigger event for this element if it has a key.\n  if (getKey(node)) {\n    var ev = document.createEvent('Event')\n    var prop = { value: node }\n    ev.initEvent(type, false, false)\n    Object.defineProperty(ev, 'target', prop)\n    Object.defineProperty(ev, 'srcElement', prop)\n    node.dispatchEvent(ev)\n  }\n\n  // Dispatch to all children.\n  var child = node.firstChild\n  while (child) child = dispatch(child, type).nextSibling\n  return node\n}\n\n/**\n * @private\n * @description\n * Confirm that a value is truthy, throws an error message otherwise.\n *\n * @param {*} val - the val to test.\n * @param {string} msg - the error message on failure.\n * @throws {Error}\n */\nfunction assert (val, msg) {\n  if (!val) throw new Error('set-dom: ' + msg)\n}\n","'use strict'\n\nvar parser = window.DOMParser && new window.DOMParser()\nvar htmlType = 'text/html'\nvar xhtmlType = 'application/xhtml+xml'\nvar testCode = '<i></i>'\nvar documentRootName = 'HTML'\nvar supportsHTMLType = false\nvar supportsXHTMLType = false\n\n// Check if browser supports text/html DOMParser\ntry {\n  /* istanbul ignore next: Fails in older browsers */\n  if (parser.parseFromString(testCode, htmlType)) supportsHTMLType = true\n} catch (err) {}\n\ntry {\n  /* istanbul ignore next: Only used in ie9 */\n  if (!supportsHTMLType && parser.parseFromString(testCode, xhtmlType)) supportsXHTMLType = true\n} catch (err) {}\n\n/**\n * Returns the results of a DOMParser as an HTMLElement.\n * (Shims for older browser and IE9).\n */\nmodule.exports = supportsHTMLType\n  ? function parseHTML (markup, rootName) {\n    var doc = parser.parseFromString(markup, htmlType)\n    return rootName === documentRootName\n      ? doc.documentElement\n      : doc.body.firstChild\n  }\n  /* istanbul ignore next: Only used in older browsers */\n  : function parseHTML (markup, rootName) {\n    var isRoot = rootName === documentRootName\n\n    // Special case for ie9 (documentElement.innerHTML not supported).\n    if (supportsXHTMLType && isRoot) {\n      return parser.parseFromString(markup, xhtmlType).documentElement\n    }\n\n    // Fallback to innerHTML for other older browsers.\n    var doc = document.implementation.createHTMLDocument('')\n    if (isRoot) {\n      doc.documentElement.innerHTML = markup\n      return doc.documentElement\n    } else {\n      doc.body.innerHTML = markup\n      return doc.body.firstChild\n    }\n  }\n","'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n  this.enableTests = false;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }, undefined, false).start();\n  }, undefined, this.enableTests).start();\n};\n\nmodule.exports = Benchmark;\n","'use strict';\n\nfunction render(nodes) {\n  var children = [];\n  var j;\n  var c;\n  var i;\n  var e;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      e = document.createElement('div');\n      c = render(n.children);\n      for (j = 0; j < c.length; j++) {\n        e.appendChild(c[j]);\n      }\n      children.push(e);\n    } else {\n      e = document.createElement('span');\n      e.textContent = n.key.toString();\n      children.push(e);\n    }\n  }\n\n  return children;\n}\n\nfunction testInnerHtml(testName, nodes, container) {\n  var c = document.createElement('div');\n  var e = document.createElement('div');\n  var children = render(nodes);\n  for (var i = 0; i < children.length; i++) {\n    e.appendChild(children[i]);\n  }\n  c.appendChild(e);\n  if (c.innerHTML !== container.innerHTML) {\n    console.log('error in test: ' + testName);\n    console.log('container.innerHTML:');\n    console.log(container.innerHTML);\n    console.log('should be:');\n    console.log(c.innerHTML);\n  }\n}\n\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb, enableTests) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n  this.enableTests = enableTests;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'render()', test.data.a, this.container);\n      }\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'update()', test.data.b, this.container);\n      }\n\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n","'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.generateBenchmarkData().units;\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n\n  if (qs['test'] !== void 0) {\n    benchmark.enableTests = true;\n    console.log('tests enabled');\n  }\n\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n","module.exports={\n  \"private\": true,\n  \"name\": \"vdom-benchmark-set-dom\",\n  \"version\": \"0.2.0\",\n  \"description\": \"Virtual DOM Benchmark: set-dom\",\n  \"license\": \"BSD\",\n  \"repository\": \"https://github.com/localvoid/vdom-benchmark-set-dom\",\n  \"author\": {\n    \"name\": \"Boris Kaul\",\n    \"email\": \"localvoid@gmail.com\",\n    \"url\": \"https://github.com/localvoid\"\n  },\n  \"keywords\": [\n    \"virtual\",\n    \"dom\",\n    \"virtualdom\",\n    \"vdom\",\n    \"diff\",\n    \"browser\",\n    \"benchmark\",\n    \"vdom-benchmark\"\n  ],\n  \"dependencies\": {\n    \"envify\": \"~4.0.0\",\n    \"set-dom\": \"7.0.4\",\n    \"vdom-benchmark-base\": \"~0.2.4\"\n  },\n  \"devDependencies\": {\n    \"browser-sync\": \"^2.18.8\",\n    \"browserify\": \"^14.1.0\",\n    \"del\": \"^2.2.2\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-gh-pages\": \"~0.5.4\",\n    \"gulp-if\": \"^2.0.2\",\n    \"gulp-sourcemaps\": \"^2.4.1\",\n    \"gulp-uglify\": \"^2.1.2\",\n    \"vinyl-buffer\": \"^1.0.0\",\n    \"vinyl-source-stream\": \"^1.1.0\"\n  }\n}\n","'use strict'\n\nvar benchmark = require('vdom-benchmark-base')\nvar setDOM = require('set-dom')\n\nvar NAME = 'set-dom'\nvar VERSION = require('../../package.json').dependencies['set-dom']\n\nfunction renderTree (nodes, parent, depth) {\n  var e\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i]\n    if (n.children !== null) {\n      e = document.createElement('div')\n      e.id = '' + depth + '_' + n.key\n      parent.appendChild(e)\n      renderTree(n.children, e, depth + 1)\n    } else {\n      e = document.createElement('span')\n      e.id = '' + depth + '_' + n.key\n      e.textContent = n.key\n      parent.appendChild(e)\n    }\n  }\n}\n\nfunction BenchmarkImpl (container, a, b) {\n  this.container = container\n  this.a = a\n  this.b = b\n  this._root = null\n}\n\nBenchmarkImpl.prototype.setUp = function () {}\n\nBenchmarkImpl.prototype.tearDown = function () {\n  this.container.removeChild(this.container.firstChild)\n}\n\nBenchmarkImpl.prototype.render = function () {\n  this._root = document.createElement('div')\n  renderTree(this.a, this._root, 0)\n  this.container.appendChild(this._root)\n}\n\nBenchmarkImpl.prototype.update = function () {\n  var e = document.createElement('div')\n  renderTree(this.b, e, 0)\n  setDOM(this._root, e)\n}\n\ndocument.addEventListener('DOMContentLoaded', function (e) {\n  benchmark(NAME, VERSION, BenchmarkImpl)\n}, false)\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvc2V0LWRvbS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2V0LWRvbS9zcmMvcGFyc2UtaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy92ZG9tLWJlbmNobWFyay1iYXNlL2xpYi9iZW5jaG1hcmsuanMiLCJub2RlX21vZHVsZXMvdmRvbS1iZW5jaG1hcmstYmFzZS9saWIvZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvdmRvbS1iZW5jaG1hcmstYmFzZS9saWIvaW5kZXguanMiLCJwYWNrYWdlLmpzb24iLCJ3ZWIvanMvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCdcblxuc2V0RE9NLktFWSA9ICdkYXRhLWtleSdcbnNldERPTS5JR05PUkUgPSAnZGF0YS1pZ25vcmUnXG5zZXRET00uQ0hFQ0tTVU0gPSAnZGF0YS1jaGVja3N1bSdcbnZhciBwYXJzZUhUTUwgPSByZXF1aXJlKCcuL3BhcnNlLWh0bWwnKVxudmFyIEtFWV9QUkVGSVggPSAnX3NldC1kb20tJ1xudmFyIE5PREVfTU9VTlRFRCA9IEtFWV9QUkVGSVggKyAnbW91bnRlZCdcbnZhciBNT1VOVF9FVkVOVCA9ICdtb3VudCdcbnZhciBESVNNT1VOVF9FVkVOVCA9ICdkaXNtb3VudCdcbnZhciBFTEVNRU5UX1RZUEUgPSB3aW5kb3cuTm9kZS5FTEVNRU5UX05PREVcbnZhciBET0NVTUVOVF9UWVBFID0gd2luZG93Lk5vZGUuRE9DVU1FTlRfTk9ERVxuXG4vLyBFeHBvc2UgYXBpLlxubW9kdWxlLmV4cG9ydHMgPSBzZXRET01cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVwZGF0ZXMgZXhpc3RpbmcgZG9tIHRvIG1hdGNoIGEgbmV3IGRvbS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9sZE5vZGUgLSBUaGUgaHRtbCBlbnRpdHkgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtTdHJpbmd8Tm9kZX0gbmV3Tm9kZSAtIFRoZSB1cGRhdGVkIGh0bWwoZW50aXR5KS5cbiAqL1xuZnVuY3Rpb24gc2V0RE9NIChvbGROb2RlLCBuZXdOb2RlKSB7XG4gIC8vIEVuc3VyZSBhIHJlYWxpc2ggZG9tIG5vZGUgaXMgcHJvdmlkZWQuXG4gIGFzc2VydChvbGROb2RlICYmIG9sZE5vZGUubm9kZVR5cGUsICdZb3UgbXVzdCBwcm92aWRlIGEgdmFsaWQgbm9kZSB0byB1cGRhdGUuJylcblxuICAvLyBBbGlhcyBkb2N1bWVudCBlbGVtZW50IHdpdGggZG9jdW1lbnQuXG4gIGlmIChvbGROb2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFKSBvbGROb2RlID0gb2xkTm9kZS5kb2N1bWVudEVsZW1lbnRcblxuICAvLyBJZiBhIHN0cmluZyB3YXMgcHJvdmlkZWQgd2Ugd2lsbCBwYXJzZSBpdCBhcyBkb20uXG4gIGlmICh0eXBlb2YgbmV3Tm9kZSA9PT0gJ3N0cmluZycpIG5ld05vZGUgPSBwYXJzZUhUTUwobmV3Tm9kZSwgb2xkTm9kZS5ub2RlTmFtZSlcblxuICAvLyBVcGRhdGUgdGhlIG5vZGUuXG4gIHNldE5vZGUob2xkTm9kZSwgbmV3Tm9kZSlcblxuICAvLyBUcmlnZ2VyIG1vdW50IGV2ZW50cyBvbiBpbml0aWFsIHNldC5cbiAgaWYgKCFvbGROb2RlW05PREVfTU9VTlRFRF0pIHtcbiAgICBvbGROb2RlW05PREVfTU9VTlRFRF0gPSB0cnVlXG4gICAgZGlzcGF0Y2gob2xkTm9kZSwgTU9VTlRfRVZFTlQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBVcGRhdGVzIGEgc3BlY2lmaWMgaHRtbE5vZGUgYW5kIGRvZXMgd2hhdGV2ZXIgaXQgdGFrZXMgdG8gY29udmVydCBpdCB0byBhbm90aGVyIG9uZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9sZE5vZGUgLSBUaGUgcHJldmlvdXMgSFRNTE5vZGUuXG4gKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgLSBUaGUgdXBkYXRlZCBIVE1MTm9kZS5cbiAqL1xuZnVuY3Rpb24gc2V0Tm9kZSAob2xkTm9kZSwgbmV3Tm9kZSkge1xuICBpZiAob2xkTm9kZS5ub2RlVHlwZSA9PT0gbmV3Tm9kZS5ub2RlVHlwZSkge1xuICAgIC8vIEhhbmRsZSByZWd1bGFyIGVsZW1lbnQgbm9kZSB1cGRhdGVzLlxuICAgIGlmIChvbGROb2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX1RZUEUpIHtcbiAgICAgIC8vIElnbm9yZSBlbGVtZW50cyBpZiB0aGVpciBjaGVja3N1bSBtYXRjaGVzLlxuICAgICAgaWYgKGdldENoZWNrU3VtKG9sZE5vZGUpID09PSBnZXRDaGVja1N1bShuZXdOb2RlKSkgcmV0dXJuXG4gICAgICAvLyBJZ25vcmUgZWxlbWVudHMgdGhhdCBleHBsaWNpdHkgY2hvb3NlIG5vdCB0byBiZSBkaWZmZWQuXG4gICAgICBpZiAoaXNJZ25vcmVkKG9sZE5vZGUpICYmIGlzSWdub3JlZChuZXdOb2RlKSkgcmV0dXJuXG5cbiAgICAgIC8vIFVwZGF0ZSBhbGwgY2hpbGRyZW4gKGFuZCBzdWJjaGlsZHJlbikuXG4gICAgICBzZXRDaGlsZE5vZGVzKG9sZE5vZGUsIG5ld05vZGUpXG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZWxlbWVudHMgYXR0cmlidXRlcyAvIHRhZ05hbWUuXG4gICAgICBpZiAob2xkTm9kZS5ub2RlTmFtZSA9PT0gbmV3Tm9kZS5ub2RlTmFtZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHRoZSBzYW1lIG5vZGVuYW1lIHRoZW4gd2UgY2FuIGRpcmVjdGx5IHVwZGF0ZSB0aGUgYXR0cmlidXRlcy5cbiAgICAgICAgc2V0QXR0cmlidXRlcyhvbGROb2RlLmF0dHJpYnV0ZXMsIG5ld05vZGUuYXR0cmlidXRlcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjbG9uZSB0aGUgbmV3IG5vZGUgdG8gdXNlIGFzIHRoZSBleGlzdGluZyBub2RlLlxuICAgICAgICB2YXIgbmV3UHJldiA9IG5ld05vZGUuY2xvbmVOb2RlKClcbiAgICAgICAgLy8gQ29weSBvdmVyIGFsbCBleGlzdGluZyBjaGlsZHJlbiBmcm9tIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgICAgICB3aGlsZSAob2xkTm9kZS5maXJzdENoaWxkKSBuZXdQcmV2LmFwcGVuZENoaWxkKG9sZE5vZGUuZmlyc3RDaGlsZClcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgb3JpZ2luYWwgbm9kZSB3aXRoIHRoZSBuZXcgb25lIHdpdGggdGhlIHJpZ2h0IHRhZy5cbiAgICAgICAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdQcmV2LCBvbGROb2RlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgb3RoZXIgdHlwZXMgb2Ygbm9kZSB1cGRhdGVzICh0ZXh0L2NvbW1lbnRzL2V0YykuXG4gICAgICAvLyBJZiBib3RoIGFyZSB0aGUgc2FtZSB0eXBlIG9mIG5vZGUgd2UgY2FuIHVwZGF0ZSBkaXJlY3RseS5cbiAgICAgIGlmIChvbGROb2RlLm5vZGVWYWx1ZSAhPT0gbmV3Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgb2xkTm9kZS5ub2RlVmFsdWUgPSBuZXdOb2RlLm5vZGVWYWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBoYXZlIHRvIHJlcGxhY2UgdGhlIG5vZGUuXG4gICAgZGlzcGF0Y2gob2xkTm9kZSwgRElTTU9VTlRfRVZFTlQpXG4gICAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKVxuICAgIGRpc3BhdGNoKG5ld05vZGUsIE1PVU5UX0VWRU5UKVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVXRpbGl0eSB0aGF0IHdpbGwgdXBkYXRlIG9uZSBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0ge05hbWVkTm9kZU1hcH0gb2xkQXR0cmlidXRlcyAtIFRoZSBwcmV2aW91cyBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtOYW1lZE5vZGVNYXB9IG5ld0F0dHJpYnV0ZXMgLSBUaGUgdXBkYXRlZCBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzIChvbGRBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKSB7XG4gIHZhciBpLCBhLCBiLCBucywgbmFtZVxuXG4gIC8vIFJlbW92ZSBvbGQgYXR0cmlidXRlcy5cbiAgZm9yIChpID0gb2xkQXR0cmlidXRlcy5sZW5ndGg7IGktLTspIHtcbiAgICBhID0gb2xkQXR0cmlidXRlc1tpXVxuICAgIG5zID0gYS5uYW1lc3BhY2VVUklcbiAgICBuYW1lID0gYS5sb2NhbE5hbWVcbiAgICBiID0gbmV3QXR0cmlidXRlcy5nZXROYW1lZEl0ZW1OUyhucywgbmFtZSlcbiAgICBpZiAoIWIpIG9sZEF0dHJpYnV0ZXMucmVtb3ZlTmFtZWRJdGVtTlMobnMsIG5hbWUpXG4gIH1cblxuICAvLyBTZXQgbmV3IGF0dHJpYnV0ZXMuXG4gIGZvciAoaSA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgYSA9IG5ld0F0dHJpYnV0ZXNbaV1cbiAgICBucyA9IGEubmFtZXNwYWNlVVJJXG4gICAgbmFtZSA9IGEubG9jYWxOYW1lXG4gICAgYiA9IG9sZEF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtTlMobnMsIG5hbWUpXG4gICAgaWYgKCFiKSB7XG4gICAgICAvLyBBZGQgYSBuZXcgYXR0cmlidXRlLlxuICAgICAgbmV3QXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW1OUyhucywgbmFtZSlcbiAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtTlMoYSlcbiAgICB9IGVsc2UgaWYgKGIudmFsdWUgIT09IGEudmFsdWUpIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBhdHRyaWJ1dGUuXG4gICAgICBiLnZhbHVlID0gYS52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFV0aWxpdHkgdGhhdCB3aWxsIG5vZGVzIGNoaWxkZXJuIHRvIG1hdGNoIGFub3RoZXIgbm9kZXMgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtOb2RlfSBvbGRQYXJlbnQgLSBUaGUgZXhpc3RpbmcgcGFyZW50IG5vZGUuXG4gKiBAcGFyYW0ge05vZGV9IG5ld1BhcmVudCAtIFRoZSBuZXcgcGFyZW50IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHNldENoaWxkTm9kZXMgKG9sZFBhcmVudCwgbmV3UGFyZW50KSB7XG4gIHZhciBjaGVja09sZCwgb2xkS2V5LCBjaGVja05ldywgbmV3S2V5LCBmb3VuZE5vZGUsIGtleWVkTm9kZXNcbiAgdmFyIG9sZE5vZGUgPSBvbGRQYXJlbnQuZmlyc3RDaGlsZFxuICB2YXIgbmV3Tm9kZSA9IG5ld1BhcmVudC5maXJzdENoaWxkXG4gIHZhciBleHRyYSA9IDBcblxuICAvLyBFeHRyYWN0IGtleWVkIG5vZGVzIGZyb20gcHJldmlvdXMgY2hpbGRyZW4gYW5kIGtlZXAgdHJhY2sgb2YgdG90YWwgY291bnQuXG4gIHdoaWxlIChvbGROb2RlKSB7XG4gICAgZXh0cmErK1xuICAgIGNoZWNrT2xkID0gb2xkTm9kZVxuICAgIG9sZEtleSA9IGdldEtleShjaGVja09sZClcbiAgICBvbGROb2RlID0gb2xkTm9kZS5uZXh0U2libGluZ1xuXG4gICAgaWYgKG9sZEtleSkge1xuICAgICAgaWYgKCFrZXllZE5vZGVzKSBrZXllZE5vZGVzID0ge31cbiAgICAgIGtleWVkTm9kZXNbb2xkS2V5XSA9IGNoZWNrT2xkXG4gICAgfVxuICB9XG5cbiAgLy8gTG9vcCBvdmVyIG5ldyBub2RlcyBhbmQgcGVyZm9ybSB1cGRhdGVzLlxuICBvbGROb2RlID0gb2xkUGFyZW50LmZpcnN0Q2hpbGRcbiAgd2hpbGUgKG5ld05vZGUpIHtcbiAgICBleHRyYS0tXG4gICAgY2hlY2tOZXcgPSBuZXdOb2RlXG4gICAgbmV3Tm9kZSA9IG5ld05vZGUubmV4dFNpYmxpbmdcblxuICAgIGlmIChrZXllZE5vZGVzICYmIChuZXdLZXkgPSBnZXRLZXkoY2hlY2tOZXcpKSAmJiAoZm91bmROb2RlID0ga2V5ZWROb2Rlc1tuZXdLZXldKSkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGtleSBhbmQgaXQgZXhpc3RlZCBiZWZvcmUgd2UgbW92ZSB0aGUgcHJldmlvdXMgbm9kZSB0byB0aGUgbmV3IHBvc2l0aW9uIGFuZCBkaWZmIGl0LlxuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZShmb3VuZE5vZGUsIG9sZE5vZGUpXG4gICAgICBzZXROb2RlKGZvdW5kTm9kZSwgY2hlY2tOZXcpXG4gICAgfSBlbHNlIGlmIChvbGROb2RlICYmICFnZXRLZXkob2xkTm9kZSkpIHtcbiAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBrZXlzIG9uIGVpdGhlciBzaWRlIHdlIHNpbXBseSBkaWZmIHRoZSBub2Rlcy5cbiAgICAgIGNoZWNrT2xkID0gb2xkTm9kZVxuICAgICAgb2xkTm9kZSA9IG9sZE5vZGUubmV4dFNpYmxpbmdcbiAgICAgIHNldE5vZGUoY2hlY2tPbGQsIGNoZWNrTmV3KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2Ugd2UgYXBwZW5kIG9yIGluc2VydCB0aGUgbmV3IG5vZGUgYXQgdGhlIHByb3BlciBwb3NpdGlvbi5cbiAgICAgIG9sZFBhcmVudC5pbnNlcnRCZWZvcmUoY2hlY2tOZXcsIG9sZE5vZGUpXG4gICAgICBkaXNwYXRjaChjaGVja05ldywgTU9VTlRfRVZFTlQpXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVuZC5cbiAgd2hpbGUgKC0tZXh0cmEgPj0gMCkge1xuICAgIG9sZFBhcmVudC5yZW1vdmVDaGlsZChkaXNwYXRjaChvbGRQYXJlbnQubGFzdENoaWxkLCBESVNNT1VOVF9FVkVOVCkpXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBVdGlsaXR5IHRvIHRyeSB0byBwdWxsIGEga2V5IG91dCBvZiBhbiBlbGVtZW50LlxuICogVXNlcyAnZGF0YS1rZXknIGlmIHBvc3NpYmxlIGFuZCBmYWxscyBiYWNrIHRvICdpZCcuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBrZXkgZm9yLlxuICogQHJldHVybiB7c3RyaW5nfHZvaWR9XG4gKi9cbmZ1bmN0aW9uIGdldEtleSAobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9UWVBFKSByZXR1cm5cbiAgdmFyIGtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKHNldERPTS5LRVkpIHx8IG5vZGUuaWRcbiAgaWYgKGtleSkgcmV0dXJuIEtFWV9QUkVGSVggKyBrZXlcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBVdGlsaXR5IHRvIHRyeSB0byBwdWxsIGEgY2hlY2tzdW0gYXR0cmlidXRlIGZyb20gYW4gZWxlbWVudC5cbiAqIFVzZXMgJ2RhdGEtY2hlY2tzdW0nIG9yIHVzZXIgc3BlY2lmaWVkIGNoZWNrc3VtIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY2hlY2tzdW0gZm9yLlxuICogQHJldHVybiB7c3RyaW5nfE5hTn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hlY2tTdW0gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKHNldERPTS5DSEVDS1NVTSkgfHwgTmFOXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVXRpbGl0eSB0byB0cnkgdG8gY2hlY2sgaWYgYW4gZWxlbWVudCBzaG91bGQgYmUgaWdub3JlZCBieSB0aGUgYWxnb3JpdGhtLlxuICogVXNlcyAnZGF0YS1pZ25vcmUnIG9yIHVzZXIgc3BlY2lmaWVkIGlnbm9yZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBjaGVjayBpZiBpdCBzaG91bGQgYmUgaWdub3JlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzSWdub3JlZCAobm9kZSkge1xuICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoc2V0RE9NLklHTk9SRSkgIT0gbnVsbFxufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyaWdnZXIgYW4gZXZlbnQgZm9yIGEgbm9kZSBhbmQgaXQncyBjaGlsZHJlbi5cbiAqIE9ubHkgZW1pdHMgZXZlbnRzIGZvciBrZXllZCBub2Rlcy5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgLSB0aGUgaW5pdGlhbCBub2RlLlxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2ggKG5vZGUsIHR5cGUpIHtcbiAgLy8gVHJpZ2dlciBldmVudCBmb3IgdGhpcyBlbGVtZW50IGlmIGl0IGhhcyBhIGtleS5cbiAgaWYgKGdldEtleShub2RlKSkge1xuICAgIHZhciBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICAgdmFyIHByb3AgPSB7IHZhbHVlOiBub2RlIH1cbiAgICBldi5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldiwgJ3RhcmdldCcsIHByb3ApXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2LCAnc3JjRWxlbWVudCcsIHByb3ApXG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2KVxuICB9XG5cbiAgLy8gRGlzcGF0Y2ggdG8gYWxsIGNoaWxkcmVuLlxuICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGRcbiAgd2hpbGUgKGNoaWxkKSBjaGlsZCA9IGRpc3BhdGNoKGNoaWxkLCB0eXBlKS5uZXh0U2libGluZ1xuICByZXR1cm4gbm9kZVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbmZpcm0gdGhhdCBhIHZhbHVlIGlzIHRydXRoeSwgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIC0gdGhlIHZhbCB0byB0ZXN0LlxuICogQHBhcmFtIHtzdHJpbmd9IG1zZyAtIHRoZSBlcnJvciBtZXNzYWdlIG9uIGZhaWx1cmUuXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKCdzZXQtZG9tOiAnICsgbXNnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBwYXJzZXIgPSB3aW5kb3cuRE9NUGFyc2VyICYmIG5ldyB3aW5kb3cuRE9NUGFyc2VyKClcbnZhciBodG1sVHlwZSA9ICd0ZXh0L2h0bWwnXG52YXIgeGh0bWxUeXBlID0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCdcbnZhciB0ZXN0Q29kZSA9ICc8aT48L2k+J1xudmFyIGRvY3VtZW50Um9vdE5hbWUgPSAnSFRNTCdcbnZhciBzdXBwb3J0c0hUTUxUeXBlID0gZmFsc2VcbnZhciBzdXBwb3J0c1hIVE1MVHlwZSA9IGZhbHNlXG5cbi8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydHMgdGV4dC9odG1sIERPTVBhcnNlclxudHJ5IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IEZhaWxzIGluIG9sZGVyIGJyb3dzZXJzICovXG4gIGlmIChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRlc3RDb2RlLCBodG1sVHlwZSkpIHN1cHBvcnRzSFRNTFR5cGUgPSB0cnVlXG59IGNhdGNoIChlcnIpIHt9XG5cbnRyeSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBPbmx5IHVzZWQgaW4gaWU5ICovXG4gIGlmICghc3VwcG9ydHNIVE1MVHlwZSAmJiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRlc3RDb2RlLCB4aHRtbFR5cGUpKSBzdXBwb3J0c1hIVE1MVHlwZSA9IHRydWVcbn0gY2F0Y2ggKGVycikge31cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGEgRE9NUGFyc2VyIGFzIGFuIEhUTUxFbGVtZW50LlxuICogKFNoaW1zIGZvciBvbGRlciBicm93c2VyIGFuZCBJRTkpLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzSFRNTFR5cGVcbiAgPyBmdW5jdGlvbiBwYXJzZUhUTUwgKG1hcmt1cCwgcm9vdE5hbWUpIHtcbiAgICB2YXIgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhtYXJrdXAsIGh0bWxUeXBlKVxuICAgIHJldHVybiByb290TmFtZSA9PT0gZG9jdW1lbnRSb290TmFtZVxuICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50XG4gICAgICA6IGRvYy5ib2R5LmZpcnN0Q2hpbGRcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogT25seSB1c2VkIGluIG9sZGVyIGJyb3dzZXJzICovXG4gIDogZnVuY3Rpb24gcGFyc2VIVE1MIChtYXJrdXAsIHJvb3ROYW1lKSB7XG4gICAgdmFyIGlzUm9vdCA9IHJvb3ROYW1lID09PSBkb2N1bWVudFJvb3ROYW1lXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGllOSAoZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTCBub3Qgc3VwcG9ydGVkKS5cbiAgICBpZiAoc3VwcG9ydHNYSFRNTFR5cGUgJiYgaXNSb290KSB7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhtYXJrdXAsIHhodG1sVHlwZSkuZG9jdW1lbnRFbGVtZW50XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gaW5uZXJIVE1MIGZvciBvdGhlciBvbGRlciBicm93c2Vycy5cbiAgICB2YXIgZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKVxuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gbWFya3VwXG4gICAgICByZXR1cm4gZG9jLmRvY3VtZW50RWxlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICBkb2MuYm9keS5pbm5lckhUTUwgPSBtYXJrdXBcbiAgICAgIHJldHVybiBkb2MuYm9keS5maXJzdENoaWxkXG4gICAgfVxuICB9XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRvciA9IHJlcXVpcmUoJy4vZXhlY3V0b3InKTtcblxuZnVuY3Rpb24gQmVuY2htYXJrKCkge1xuICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgdGhpcy5pbXBsID0gbnVsbDtcbiAgdGhpcy50ZXN0cyA9IG51bGw7XG4gIHRoaXMucmVwb3J0Q2FsbGJhY2sgPSBudWxsO1xuICB0aGlzLmVuYWJsZVRlc3RzID0gZmFsc2U7XG5cbiAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICB0aGlzLl9ydW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnUnVuQnV0dG9uJyk7XG4gIHRoaXMuX2l0ZXJhdGlvbnNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ0l0ZXJhdGlvbnMnKTtcbiAgdGhpcy5fcmVwb3J0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3JlcG9ydEVsZW1lbnQpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9ydW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKCFzZWxmLnJ1bm5pbmcpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gcGFyc2VJbnQoc2VsZi5faXRlcmF0aW9uc0VsZW1lbnQudmFsdWUpO1xuICAgICAgaWYgKGl0ZXJhdGlvbnMgPD0gMCkge1xuICAgICAgICBpdGVyYXRpb25zID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucnVuKGl0ZXJhdGlvbnMpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHRoaXMucmVhZHkodHJ1ZSk7XG59XG5cbkJlbmNobWFyay5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbih2KSB7XG4gIGlmICh2KSB7XG4gICAgdGhpcy5fcnVuQnV0dG9uLmRpc2FibGVkID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcnVuQnV0dG9uLmRpc2FibGVkID0gJ3RydWUnO1xuICB9XG59O1xuXG5CZW5jaG1hcmsucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGl0ZXJhdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICB0aGlzLnJlYWR5KGZhbHNlKTtcblxuICBuZXcgRXhlY3V0b3Ioc2VsZi5pbXBsLCBzZWxmLmNvbnRhaW5lciwgc2VsZi50ZXN0cywgMSwgZnVuY3Rpb24oKSB7IC8vIHdhcm11cFxuICAgIG5ldyBFeGVjdXRvcihzZWxmLmltcGwsIHNlbGYuY29udGFpbmVyLCBzZWxmLnRlc3RzLCBpdGVyYXRpb25zLCBmdW5jdGlvbihzYW1wbGVzKSB7XG4gICAgICBzZWxmLl9yZXBvcnRFbGVtZW50LnRleHRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoc2FtcGxlcywgbnVsbCwgJyAnKTtcbiAgICAgIHNlbGYucnVubmluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5yZWFkeSh0cnVlKTtcbiAgICAgIGlmIChzZWxmLnJlcG9ydENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2VsZi5yZXBvcnRDYWxsYmFjayhzYW1wbGVzKTtcbiAgICAgIH1cbiAgICB9LCB1bmRlZmluZWQsIGZhbHNlKS5zdGFydCgpO1xuICB9LCB1bmRlZmluZWQsIHRoaXMuZW5hYmxlVGVzdHMpLnN0YXJ0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlbmNobWFyaztcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcmVuZGVyKG5vZGVzKSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgajtcbiAgdmFyIGM7XG4gIHZhciBpO1xuICB2YXIgZTtcbiAgdmFyIG47XG5cbiAgZm9yIChpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbiA9IG5vZGVzW2ldO1xuICAgIGlmIChuLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjID0gcmVuZGVyKG4uY2hpbGRyZW4pO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZS5hcHBlbmRDaGlsZChjW2pdKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnB1c2goZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBlLnRleHRDb250ZW50ID0gbi5rZXkudG9TdHJpbmcoKTtcbiAgICAgIGNoaWxkcmVuLnB1c2goZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiB0ZXN0SW5uZXJIdG1sKHRlc3ROYW1lLCBub2RlcywgY29udGFpbmVyKSB7XG4gIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBjaGlsZHJlbiA9IHJlbmRlcihub2Rlcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBlLmFwcGVuZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgfVxuICBjLmFwcGVuZENoaWxkKGUpO1xuICBpZiAoYy5pbm5lckhUTUwgIT09IGNvbnRhaW5lci5pbm5lckhUTUwpIHtcbiAgICBjb25zb2xlLmxvZygnZXJyb3IgaW4gdGVzdDogJyArIHRlc3ROYW1lKTtcbiAgICBjb25zb2xlLmxvZygnY29udGFpbmVyLmlubmVySFRNTDonKTtcbiAgICBjb25zb2xlLmxvZyhjb250YWluZXIuaW5uZXJIVE1MKTtcbiAgICBjb25zb2xlLmxvZygnc2hvdWxkIGJlOicpO1xuICAgIGNvbnNvbGUubG9nKGMuaW5uZXJIVE1MKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIEV4ZWN1dG9yKGltcGwsIGNvbnRhaW5lciwgdGVzdHMsIGl0ZXJhdGlvbnMsIGNiLCBpdGVyQ2IsIGVuYWJsZVRlc3RzKSB7XG4gIGlmIChpdGVyQ2IgPT09IHZvaWQgMCkgaXRlckNiID0gbnVsbDtcblxuICB0aGlzLmltcGwgPSBpbXBsO1xuICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgdGhpcy50ZXN0cyA9IHRlc3RzO1xuICB0aGlzLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaXRlckNiID0gaXRlckNiO1xuICB0aGlzLmVuYWJsZVRlc3RzID0gZW5hYmxlVGVzdHM7XG5cbiAgdGhpcy5fY3VycmVudFRlc3QgPSAwO1xuICB0aGlzLl9jdXJyZW50SXRlciA9IDA7XG4gIHRoaXMuX3JlbmRlclNhbXBsZXMgPSBbXTtcbiAgdGhpcy5fdXBkYXRlU2FtcGxlcyA9IFtdO1xuICB0aGlzLl9yZXN1bHQgPSBbXTtcblxuICB0aGlzLl90YXNrc0NvdW50ID0gdGVzdHMubGVuZ3RoICogaXRlcmF0aW9ucztcblxuICB0aGlzLl9pdGVyID0gdGhpcy5pdGVyLmJpbmQodGhpcyk7XG59XG5cbkV4ZWN1dG9yLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9pdGVyKCk7XG59O1xuXG5FeGVjdXRvci5wcm90b3R5cGUuZmluaXNoZWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYih0aGlzLl9yZXN1bHQpO1xufTtcblxuRXhlY3V0b3IucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9jdXJyZW50VGVzdCA9PT0gMCAmJiB0aGlzLl9jdXJyZW50SXRlciA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHRlc3RzID0gdGhpcy50ZXN0cztcbiAgcmV0dXJuICh0aGlzLl9jdXJyZW50VGVzdCAqIHRlc3RzLmxlbmd0aCArIHRoaXMuX2N1cnJlbnRJdGVyKSAvICh0ZXN0cy5sZW5ndGggKiB0aGlzLml0ZXJhdGFpb25zKTtcbn07XG5cbkV4ZWN1dG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLml0ZXJDYiAhPSBudWxsKSB7XG4gICAgdGhpcy5pdGVyQ2IodGhpcyk7XG4gIH1cblxuICB2YXIgdGVzdHMgPSB0aGlzLnRlc3RzO1xuXG4gIGlmICh0aGlzLl9jdXJyZW50VGVzdCA8IHRlc3RzLmxlbmd0aCkge1xuICAgIHZhciB0ZXN0ID0gdGVzdHNbdGhpcy5fY3VycmVudFRlc3RdO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRJdGVyIDwgdGhpcy5pdGVyYXRpb25zKSB7XG4gICAgICB2YXIgZSwgdDtcbiAgICAgIHZhciByZW5kZXJUaW1lLCB1cGRhdGVUaW1lO1xuXG4gICAgICBlID0gbmV3IHRoaXMuaW1wbCh0aGlzLmNvbnRhaW5lciwgdGVzdC5kYXRhLmEsIHRlc3QuZGF0YS5iKTtcbiAgICAgIGUuc2V0VXAoKTtcblxuICAgICAgdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGUucmVuZGVyKCk7XG4gICAgICByZW5kZXJUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gdDtcblxuICAgICAgaWYgKHRoaXMuZW5hYmxlVGVzdHMpIHtcbiAgICAgICAgdGVzdElubmVySHRtbCh0ZXN0Lm5hbWUgKyAncmVuZGVyKCknLCB0ZXN0LmRhdGEuYSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICB0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgZS51cGRhdGUoKTtcbiAgICAgIHVwZGF0ZVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuXG4gICAgICBpZiAodGhpcy5lbmFibGVUZXN0cykge1xuICAgICAgICB0ZXN0SW5uZXJIdG1sKHRlc3QubmFtZSArICd1cGRhdGUoKScsIHRlc3QuZGF0YS5iLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGUudGVhckRvd24oKTtcblxuICAgICAgdGhpcy5fcmVuZGVyU2FtcGxlcy5wdXNoKHJlbmRlclRpbWUpO1xuICAgICAgdGhpcy5fdXBkYXRlU2FtcGxlcy5wdXNoKHVwZGF0ZVRpbWUpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50SXRlcisrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN1bHQucHVzaCh7XG4gICAgICAgIG5hbWU6IHRlc3QubmFtZSArICcgJyArICdyZW5kZXIoKScsXG4gICAgICAgIGRhdGE6IHRoaXMuX3JlbmRlclNhbXBsZXMuc2xpY2UoMClcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXN1bHQucHVzaCh7XG4gICAgICAgIG5hbWU6IHRlc3QubmFtZSArICcgJyArICd1cGRhdGUoKScsXG4gICAgICAgIGRhdGE6IHRoaXMuX3VwZGF0ZVNhbXBsZXMuc2xpY2UoMClcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9jdXJyZW50VGVzdCsrO1xuXG4gICAgICB0aGlzLl9jdXJyZW50SXRlciA9IDA7XG4gICAgICB0aGlzLl9yZW5kZXJTYW1wbGVzID0gW107XG4gICAgICB0aGlzLl91cGRhdGVTYW1wbGVzID0gW107XG4gICAgfVxuXG4gICAgc2V0VGltZW91dCh0aGlzLl9pdGVyLCAwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmlzaGVkKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCZW5jaG1hcmsgPSByZXF1aXJlKCcuL2JlbmNobWFyaycpO1xudmFyIGJlbmNobWFyayA9IG5ldyBCZW5jaG1hcmsoKTtcblxuZnVuY3Rpb24gaW5pdEZyb21TY3JpcHQoc2NyaXB0VXJsLCBpbXBsKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIGUuc3JjID0gc2NyaXB0VXJsO1xuXG4gIGUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgYmVuY2htYXJrLnRlc3RzID0gd2luZG93LmdlbmVyYXRlQmVuY2htYXJrRGF0YSgpLnVuaXRzO1xuICAgIGJlbmNobWFyay5yZWFkeSh0cnVlKTtcbiAgfTtcblxuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpO1xufVxuXG5mdW5jdGlvbiBpbml0RnJvbVBhcmVudFdpbmRvdyhwYXJlbnQsIG5hbWUsIHZlcnNpb24sIGlkKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICd0ZXN0cycpIHtcbiAgICAgIGJlbmNobWFyay50ZXN0cyA9IGRhdGEuZGF0YTtcbiAgICAgIGJlbmNobWFyay5yZXBvcnRDYWxsYmFjayA9IGZ1bmN0aW9uKHNhbXBsZXMpIHtcbiAgICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiAncmVwb3J0JyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgIHNhbXBsZXM6IHNhbXBsZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9LCAnKicpO1xuICAgICAgfTtcbiAgICAgIGJlbmNobWFyay5yZWFkeSh0cnVlKTtcblxuICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3JlYWR5JyxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgaWQ6IGlkXG4gICAgICB9LCAnKicpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3J1bicpIHtcbiAgICAgIGJlbmNobWFyay5ydW4oZGF0YS5kYXRhLml0ZXJhdGlvbnMpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHBhcmVudC5wb3N0TWVzc2FnZSh7XG4gICAgdHlwZTogJ2luaXQnLFxuICAgIGRhdGE6IG51bGwsXG4gICAgaWQ6IGlkXG4gIH0sICcqJyk7XG59XG5cbmZ1bmN0aW9uIGluaXQobmFtZSwgdmVyc2lvbiwgaW1wbCkge1xuICAvLyBQYXJzZSBRdWVyeSBTdHJpbmcuXG4gIHZhciBxcyA9IChmdW5jdGlvbihhKSB7XG4gICAgaWYgKGEgPT0gXCJcIikgcmV0dXJuIHt9O1xuICAgIHZhciBiID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcD1hW2ldLnNwbGl0KCc9JywgMik7XG4gICAgICBpZiAocC5sZW5ndGggPT0gMSkge1xuICAgICAgICBiW3BbMF1dID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJbcFswXV0gPSBkZWNvZGVVUklDb21wb25lbnQocFsxXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGI7XG4gIH0pKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpLnNwbGl0KCcmJykpO1xuXG4gIGlmIChxc1snbmFtZSddICE9PSB2b2lkIDApIHtcbiAgICBuYW1lID0gcXNbJ25hbWUnXTtcbiAgfVxuXG4gIGlmIChxc1sndmVyc2lvbiddICE9PSB2b2lkIDApIHtcbiAgICB2ZXJzaW9uID0gcXNbJ3ZlcnNpb24nXTtcbiAgfVxuXG4gIHZhciB0eXBlID0gcXNbJ3R5cGUnXTtcblxuICBpZiAocXNbJ3Rlc3QnXSAhPT0gdm9pZCAwKSB7XG4gICAgYmVuY2htYXJrLmVuYWJsZVRlc3RzID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZygndGVzdHMgZW5hYmxlZCcpO1xuICB9XG5cbiAgdmFyIGlkO1xuICBpZiAodHlwZSA9PT0gJ2lmcmFtZScpIHtcbiAgICBpZCA9IHFzWydpZCddO1xuICAgIGlmIChpZCA9PT0gdm9pZCAwKSBpZCA9IG51bGw7XG4gICAgaW5pdEZyb21QYXJlbnRXaW5kb3cod2luZG93LnBhcmVudCwgbmFtZSwgdmVyc2lvbiwgaWQpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd3aW5kb3cnKSB7XG4gICAgaWYgKHdpbmRvdy5vcGVuZXIgIT0gbnVsbCkge1xuICAgICAgaWQgPSBxc1snaWQnXTtcbiAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSBpZCA9IG51bGw7XG4gICAgICBpbml0RnJvbVBhcmVudFdpbmRvdyh3aW5kb3cub3BlbmVyLCBuYW1lLCB2ZXJzaW9uLCBpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZTogb3BlbmVyIHdpbmRvdyBpcyBOVUxMJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0ZXN0c1VybCA9IHFzWydkYXRhJ107IC8vIHVybCB0byB0aGUgc2NyaXB0IGdlbmVyYXRpbmcgdGVzdCBkYXRhXG4gICAgaWYgKHRlc3RzVXJsICE9PSB2b2lkIDApIHtcbiAgICAgIGluaXRGcm9tU2NyaXB0KHRlc3RzVXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBpbml0aWFsaXplOiBjYW5ub3QgbG9hZCB0ZXN0cyBkYXRhJyk7XG4gICAgfVxuICB9XG5cbiAgYmVuY2htYXJrLmltcGwgPSBpbXBsO1xufVxuXG4vLyBwZXJmb3JtYW5jZS5ub3coKSBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzU0Mzg2NTBcbi8vIHByZXBhcmUgYmFzZSBwZXJmIG9iamVjdFxuaWYgKHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHt9O1xufVxuaWYgKCF3aW5kb3cucGVyZm9ybWFuY2Uubm93KXtcbiAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG4gIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCkge1xuICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gIH1cbiAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uIG5vdygpe1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQ7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwicHJpdmF0ZVwiOiB0cnVlLFxuICBcIm5hbWVcIjogXCJ2ZG9tLWJlbmNobWFyay1zZXQtZG9tXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuMi4wXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJWaXJ0dWFsIERPTSBCZW5jaG1hcms6IHNldC1kb21cIixcbiAgXCJsaWNlbnNlXCI6IFwiQlNEXCIsXG4gIFwicmVwb3NpdG9yeVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9sb2NhbHZvaWQvdmRvbS1iZW5jaG1hcmstc2V0LWRvbVwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQm9yaXMgS2F1bFwiLFxuICAgIFwiZW1haWxcIjogXCJsb2NhbHZvaWRAZ21haWwuY29tXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vbG9jYWx2b2lkXCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJ2aXJ0dWFsXCIsXG4gICAgXCJkb21cIixcbiAgICBcInZpcnR1YWxkb21cIixcbiAgICBcInZkb21cIixcbiAgICBcImRpZmZcIixcbiAgICBcImJyb3dzZXJcIixcbiAgICBcImJlbmNobWFya1wiLFxuICAgIFwidmRvbS1iZW5jaG1hcmtcIlxuICBdLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJlbnZpZnlcIjogXCJ+NC4wLjBcIixcbiAgICBcInNldC1kb21cIjogXCI3LjAuNFwiLFxuICAgIFwidmRvbS1iZW5jaG1hcmstYmFzZVwiOiBcIn4wLjIuNFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXItc3luY1wiOiBcIl4yLjE4LjhcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTQuMS4wXCIsXG4gICAgXCJkZWxcIjogXCJeMi4yLjJcIixcbiAgICBcImd1bHBcIjogXCJeMy45LjFcIixcbiAgICBcImd1bHAtZ2gtcGFnZXNcIjogXCJ+MC41LjRcIixcbiAgICBcImd1bHAtaWZcIjogXCJeMi4wLjJcIixcbiAgICBcImd1bHAtc291cmNlbWFwc1wiOiBcIl4yLjQuMVwiLFxuICAgIFwiZ3VscC11Z2xpZnlcIjogXCJeMi4xLjJcIixcbiAgICBcInZpbnlsLWJ1ZmZlclwiOiBcIl4xLjAuMFwiLFxuICAgIFwidmlueWwtc291cmNlLXN0cmVhbVwiOiBcIl4xLjEuMFwiXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYmVuY2htYXJrID0gcmVxdWlyZSgndmRvbS1iZW5jaG1hcmstYmFzZScpXG52YXIgc2V0RE9NID0gcmVxdWlyZSgnc2V0LWRvbScpXG5cbnZhciBOQU1FID0gJ3NldC1kb20nXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLmRlcGVuZGVuY2llc1snc2V0LWRvbSddXG5cbmZ1bmN0aW9uIHJlbmRlclRyZWUgKG5vZGVzLCBwYXJlbnQsIGRlcHRoKSB7XG4gIHZhciBlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldXG4gICAgaWYgKG4uY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZS5pZCA9ICcnICsgZGVwdGggKyAnXycgKyBuLmtleVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGUpXG4gICAgICByZW5kZXJUcmVlKG4uY2hpbGRyZW4sIGUsIGRlcHRoICsgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgZS5pZCA9ICcnICsgZGVwdGggKyAnXycgKyBuLmtleVxuICAgICAgZS50ZXh0Q29udGVudCA9IG4ua2V5XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmVuY2htYXJrSW1wbCAoY29udGFpbmVyLCBhLCBiKSB7XG4gIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyXG4gIHRoaXMuYSA9IGFcbiAgdGhpcy5iID0gYlxuICB0aGlzLl9yb290ID0gbnVsbFxufVxuXG5CZW5jaG1hcmtJbXBsLnByb3RvdHlwZS5zZXRVcCA9IGZ1bmN0aW9uICgpIHt9XG5cbkJlbmNobWFya0ltcGwucHJvdG90eXBlLnRlYXJEb3duID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lci5maXJzdENoaWxkKVxufVxuXG5CZW5jaG1hcmtJbXBsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICByZW5kZXJUcmVlKHRoaXMuYSwgdGhpcy5fcm9vdCwgMClcbiAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdClcbn1cblxuQmVuY2htYXJrSW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHJlbmRlclRyZWUodGhpcy5iLCBlLCAwKVxuICBzZXRET00odGhpcy5fcm9vdCwgZSlcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIChlKSB7XG4gIGJlbmNobWFyayhOQU1FLCBWRVJTSU9OLCBCZW5jaG1hcmtJbXBsKVxufSwgZmFsc2UpXG4iXX0="}