{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","web/js/main.js","main.js","node_modules/morphdom/lib/index.js","node_modules/vdom-benchmark-base/lib/benchmark.js","node_modules/vdom-benchmark-base/lib/executor.js","node_modules/vdom-benchmark-base/lib/index.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","renderTree","nodes","parent","depth","children","document","createElement","id","key","appendChild","textContent","BenchmarkImpl","container","b","this","_root","benchmark","morphdom","NAME","VERSION","prototype","setUp","tearDown","removeChild","firstChild","render","update","addEventListener","vdom-benchmark-base",2,"noop","morphAttrs","fromNode","toNode","attr","attrName","attrValue","attrs","attributes","foundAttrs","specified","name","value","getAttribute","setAttribute","hasOwnProperty","removeAttribute","moveChildren","from","to","curChild","nextChild","nextSibling","options","removeNodeHelper","node","nestedInSavedEl","savedEls","onNodeDiscarded","nodeType","walkDiscardedChildNodes","removeNode","parentNode","alreadyVisited","morphEl","onBeforeMorphEl","onBeforeMorphElChildren","curToNodeId","fromNextSibling","toNextSibling","savedEl","unmatchedEl","curToNodeChild","curFromNodeChild","outer","curFromNodeId","unmatchedEls","replaceChild","curFromNodeType","isCompatible","tagName","nodeValue","specialElHandler","specialElHandlers","newBodyEl","innerHTML","childNodes","morphedNode","morphedNodeType","toNodeType","savedElId","OPTION","fromEl","toEl","selected","INPUT","checked","hasAttribute",3,"Benchmark","running","impl","tests","reportCallback","enableTests","_runButton","getElementById","_iterationsElement","_reportElement","body","self","preventDefault","iterations","parseInt","run","ready","Executor","v","disabled","samples","JSON","stringify","undefined","start","./executor",4,"j","c","push","toString","testInnerHtml","testName","console","log","cb","iterCb","_currentTest","_currentIter","_renderSamples","_updateSamples","_result","_tasksCount","_iter","iter","bind","finished","progress","iterataions","test","renderTime","updateTime","data","window","performance","now","slice","setTimeout",5,"initFromScript","scriptUrl","src","onload","generateBenchmarkData","units","head","initFromParentWindow","version","type","postMessage","init","qs","p","split","decodeURIComponent","replace","location","search","substr","opener","testsUrl","nowOffset","Date","timing","navigationStart","./benchmark"],"mappings":"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","file":"main.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar benchmark = require('vdom-benchmark-base');\nvar morphdom = require('morphdom');\n\nvar NAME = 'morphdom';\nvar VERSION = '0.1.10';\n\nfunction renderTree(nodes, parent, depth) {\n  var e;\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    if (n.children !== null) {\n      e = document.createElement('div');\n      e.id = '' + depth + '_' + n.key;\n      parent.appendChild(e);\n      renderTree(n.children, e, depth + 1);\n    } else {\n      e = document.createElement('span');\n      e.id = '' + depth + '_' + n.key;\n      e.textContent = n.key;\n      parent.appendChild(e);\n    }\n  }\n}\n\nfunction BenchmarkImpl(container, a, b) {\n  this.container = container;\n  this.a = a;\n  this.b = b;\n  this._root = null;\n}\n\nBenchmarkImpl.prototype.setUp = function() {\n};\n\nBenchmarkImpl.prototype.tearDown = function() {\n  this.container.removeChild(this.container.firstChild);\n};\n\nBenchmarkImpl.prototype.render = function() {\n  this._root = document.createElement('div');\n  renderTree(this.a, this._root, 0);\n  this.container.appendChild(this._root);\n};\n\nBenchmarkImpl.prototype.update = function() {\n  var e = document.createElement('div');\n  renderTree(this.b, e, 0);\n  morphdom(this._root, e);\n};\n\ndocument.addEventListener('DOMContentLoaded', function(e) {\n  benchmark(NAME, VERSION, BenchmarkImpl);\n}, false);\n",null,"var specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think\n     * that \"selected\" is an attribute when reading\n     * over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        if ((fromEl.selected = toEl.selected)) {\n            fromEl.setAttribute('selected', '');\n        } else {\n            fromEl.removeAttribute('selected', '');\n        }\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element\n     * since it sets the initial value. Changing the \"value\"\n     * attribute without changing the \"value\" property will have\n     * no effect since it is only used to the set the initial value.\n     * Similar for the \"checked\" attribute.\n     */\n    INPUT: function(fromEl, toEl) {\n        fromEl.checked = toEl.checked;\n        fromEl.value = toEl.value;\n\n        if (!toEl.hasAttribute('checked')) {\n            fromEl.removeAttribute('checked');\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    }\n};\n\nfunction noop() {}\n\n/**\n * Loop over all of the attributes on the target node and make sure the\n * original DOM node has the same attributes. If an attribute\n * found on the original node is not on the new node then remove it from\n * the original node\n * @param  {HTMLElement} fromNode\n * @param  {HTMLElement} toNode\n */\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrValue;\n    var foundAttrs = {};\n\n    for (i=attrs.length-1; i>=0; i--) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrValue = attr.value;\n            foundAttrs[attrName] = true;\n\n            if (fromNode.getAttribute(attrName) !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Delete any extra attributes found on the original DOM element that weren't\n    // found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i=attrs.length-1; i>=0; i--) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            if (!foundAttrs.hasOwnProperty(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(from, to) {\n    var curChild = from.firstChild;\n    while(curChild) {\n        var nextChild = curChild.nextSibling;\n        to.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return to;\n}\n\nfunction morphdom(fromNode, toNode, options) {\n    if (!options) {\n        options = {};\n    }\n\n    if (typeof toNode === 'string') {\n        var newBodyEl = document.createElement('body');\n        newBodyEl.innerHTML = toNode;\n        toNode = newBodyEl.childNodes[0];\n    }\n\n    var savedEls = {}; // Used to save off DOM elements with IDs\n    var unmatchedEls = {};\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeMorphEl = options.onBeforeMorphEl || noop;\n    var onBeforeMorphElChildren = options.onBeforeMorphElChildren || noop;\n\n    function removeNodeHelper(node, nestedInSavedEl) {\n        var id = node.id;\n        // If the node has an ID then save it off since we will want\n        // to reuse it in case the target DOM tree has a DOM element\n        // with the same ID\n        if (id) {\n            savedEls[id] = node;\n        } else if (!nestedInSavedEl) {\n            // If we are not nested in a saved element then we know that this node has been\n            // completely discarded and will not exist in the final DOM.\n            onNodeDiscarded(node);\n        }\n\n        if (node.nodeType === 1) {\n            var curChild = node.firstChild;\n            while(curChild) {\n                removeNodeHelper(curChild, nestedInSavedEl || id);\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    function walkDiscardedChildNodes(node) {\n        if (node.nodeType === 1) {\n            var curChild = node.firstChild;\n            while(curChild) {\n\n\n                if (!curChild.id) {\n                    // We only want to handle nodes that don't have an ID to avoid double\n                    // walking the same saved element.\n\n                    onNodeDiscarded(curChild);\n\n                    // Walk recursively\n                    walkDiscardedChildNodes(curChild);\n                }\n\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    function removeNode(node, parentNode, alreadyVisited) {\n        parentNode.removeChild(node);\n\n        if (alreadyVisited) {\n            if (!node.id) {\n                onNodeDiscarded(node);\n                walkDiscardedChildNodes(node);\n            }\n        } else {\n            removeNodeHelper(node);\n        }\n    }\n\n    function morphEl(fromNode, toNode, alreadyVisited) {\n        if (toNode.id) {\n            // If an element with an ID is being morphed then it is will be in the final\n            // DOM so clear it out of the saved elements collection\n            delete savedEls[toNode.id];\n        }\n\n        if (onBeforeMorphEl(fromNode, toNode) === false) {\n            return;\n        }\n\n        morphAttrs(fromNode, toNode);\n\n        if (onBeforeMorphElChildren(fromNode, toNode) === false) {\n            return;\n        }\n\n        var curToNodeChild = toNode.firstChild;\n        var curFromNodeChild = fromNode.firstChild;\n        var curToNodeId;\n\n        var fromNextSibling;\n        var toNextSibling;\n        var savedEl;\n        var unmatchedEl;\n\n        outer: while(curToNodeChild) {\n            toNextSibling = curToNodeChild.nextSibling;\n            curToNodeId = curToNodeChild.id;\n\n            while(curFromNodeChild) {\n                var curFromNodeId = curFromNodeChild.id;\n                fromNextSibling = curFromNodeChild.nextSibling;\n\n                if (!alreadyVisited) {\n                    if (curFromNodeId && (unmatchedEl = unmatchedEls[curFromNodeId])) {\n                        unmatchedEl.parentNode.replaceChild(curFromNodeChild, unmatchedEl);\n                        morphEl(curFromNodeChild, unmatchedEl, alreadyVisited);\n                        curFromNodeChild = fromNextSibling;\n                        continue;\n                    }\n                }\n\n                var curFromNodeType = curFromNodeChild.nodeType;\n\n                if (curFromNodeType === curToNodeChild.nodeType) {\n                    var isCompatible = false;\n\n                    if (curFromNodeType === 1) { // Both nodes being compared are Element nodes\n                        if (curFromNodeChild.tagName === curToNodeChild.tagName) {\n                            // We have compatible DOM elements\n                            if (curFromNodeId || curToNodeId) {\n                                // If either DOM element has an ID then we handle\n                                // those differently since we want to match up\n                                // by ID\n                                if (curToNodeId === curFromNodeId) {\n                                    isCompatible = true;\n                                }\n                            } else {\n                                isCompatible = true;\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // We found compatible DOM elements so transform the current \"from\" node\n                            // to match the current target DOM node.\n                            morphEl(curFromNodeChild, curToNodeChild, alreadyVisited);\n                        }\n                    } else if (curFromNodeType === 3) { // Both nodes being compared are Text nodes\n                        isCompatible = true;\n                        // Simply update nodeValue on the original node to change the text value\n                        curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                    }\n\n                    if (isCompatible) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n                }\n\n                // No compatible match so remove the old node from the DOM and continue trying\n                // to find a match in the original DOM\n                removeNode(curFromNodeChild, fromNode, alreadyVisited);\n                curFromNodeChild = fromNextSibling;\n            }\n\n            if (curToNodeId) {\n                if ((savedEl = savedEls[curToNodeId])) {\n                    morphEl(savedEl, curToNodeChild, true);\n                    curToNodeChild = savedEl; // We want to append the saved element instead\n                } else {\n                    // The current DOM element in the target tree has an ID\n                    // but we did not find a match in any of the corresponding\n                    // siblings. We just put the target element in the old DOM tree\n                    // but if we later find an element in the old DOM tree that has\n                    // a matching ID then we will replace the target element\n                    // with the corresponding old element and morph the old element\n                    unmatchedEls[curToNodeId] = curToNodeChild;\n                }\n            }\n\n            // If we got this far then we did not find a candidate match for our \"to node\"\n            // and we exhausted all of the children \"from\" nodes. Therefore, we will just\n            // append the current \"to node\" to the end\n            fromNode.appendChild(curToNodeChild);\n\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n        }\n\n        // We have processed all of the \"to nodes\". If curFromNodeChild is non-null then\n        // we still have some from nodes left over that need to be removed\n        while(curFromNodeChild) {\n            fromNextSibling = curFromNodeChild.nextSibling;\n            removeNode(curFromNodeChild, fromNode, alreadyVisited);\n            curFromNodeChild = fromNextSibling;\n        }\n\n        var specialElHandler = specialElHandlers[fromNode.tagName];\n        if (specialElHandler) {\n            specialElHandler(fromNode, toNode);\n        }\n    }\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    // Handle the case where we are given two DOM nodes that are not\n    // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n    if (morphedNodeType === 1) {\n        if (toNodeType === 1) {\n            if (morphedNode.tagName !== toNode.tagName) {\n                onNodeDiscarded(fromNode);\n                morphedNode = moveChildren(morphedNode, document.createElement(toNode.tagName));\n            }\n        } else {\n            // Going from an element node to a text node\n            return toNode;\n        }\n    } else if (morphedNodeType === 3) { // Text node\n        if (toNodeType === 3) {\n            morphedNode.nodeValue = toNode.nodeValue;\n            return morphedNode;\n        } else {\n            onNodeDiscarded(fromNode);\n            // Text node to something else\n            return toNode;\n        }\n    }\n\n    morphEl(morphedNode, toNode, false);\n\n    // Fire the \"onNodeDiscarded\" event for any saved elements\n    // that never found a new home in the morphed DOM\n    for (var savedElId in savedEls) {\n        if (savedEls.hasOwnProperty(savedElId)) {\n            var savedEl = savedEls[savedElId];\n            onNodeDiscarded(savedEl);\n            walkDiscardedChildNodes(savedEl);\n        }\n    }\n\n    if (morphedNode !== fromNode && fromNode.parentNode) {\n        // If we had to swap out the from node with a new node because the old\n        // node was not compatible with the target node then we need to\n        // replace the old DOM node in the original DOM tree. This is only\n        // possible if the original DOM node was part of a DOM tree which\n        // we know is the case if it has a parent node.\n        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n}\n\nmodule.exports = morphdom;","'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n  this.enableTests = false;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }, undefined, false).start();\n  }, undefined, this.enableTests).start();\n};\n\nmodule.exports = Benchmark;\n","'use strict';\n\nfunction render(nodes) {\n  var children = [];\n  var j;\n  var c;\n  var i;\n  var e;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      e = document.createElement('div');\n      c = render(n.children);\n      for (j = 0; j < c.length; j++) {\n        e.appendChild(c[j]);\n      }\n      children.push(e);\n    } else {\n      e = document.createElement('span');\n      e.textContent = n.key.toString();\n      children.push(e);\n    }\n  }\n\n  return children;\n}\n\nfunction testInnerHtml(testName, nodes, container) {\n  var c = document.createElement('div');\n  var e = document.createElement('div');\n  var children = render(nodes);\n  for (var i = 0; i < children.length; i++) {\n    e.appendChild(children[i]);\n  }\n  c.appendChild(e);\n  if (c.innerHTML !== container.innerHTML) {\n    console.log('error in test: ' + testName);\n    console.log('container.innerHTML:');\n    console.log(container.innerHTML);\n    console.log('should be:');\n    console.log(c.innerHTML);\n  }\n}\n\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb, enableTests) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n  this.enableTests = enableTests;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'render()', test.data.a, this.container);\n      }\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'update()', test.data.b, this.container);\n      }\n\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n","'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.generateBenchmarkData().units;\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n\n  if (qs['test'] !== void 0) {\n    benchmark.enableTests = true;\n    console.log('tests enabled');\n  }\n\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n"],"sourceRoot":"/source/"}